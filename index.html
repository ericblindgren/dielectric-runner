<!doctype html>
<html lang="en">
<!--
Dielectric Runner - An Electrostatics Game
Copyright (C) 2026 Eric B. Lindgren

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the LICENSE file (GPLv3) for details.
-->
<!-- SPDX-License-Identifier: GPL-3.0-or-later -->
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dielectric Runner</title>
  
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Crect width='16' height='16' fill='%23050510'/%3E%3Cpath d='M2 8c2-4 4-4 6 0s4 4 6 0' fill='none' stroke='%2300f3ff' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Press+Start+2P&display=swap" rel="stylesheet">

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics-compat.js"></script>

  <style>
    /* Responsive UI styling for Dielectric Runner */
    :root{
      --bg: #050510;
      --ui-bg: rgba(10, 10, 20, 0.85);
      --accent: #00f3ff;
      --danger: #ff0055;
      --text: #e0e6ff;
      --retro-pink: #ff00de;
      --retro-highlight: #ff3300;
      --retro-grid: rgba(255, 0, 222, 0.12);
    }

    @keyframes flicker{0%,18%,22%,25%,53%,57%,100%{opacity:1;transform:skew(-5deg) scale(1);}20%,24%,55%{opacity:0.5;transform:skew(-5deg) scale(0.98);}}

    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Segoe UI, Roboto, Helvetica, Arial, sans-serif;overflow:hidden}
    body{display:grid;place-items:center}

    .wrap{position:relative;width:100%;height:100%;display:flex;justify-content:center;align-items:center;background:radial-gradient(circle at center,#1a1a2e 0%,#000 100%)}
    canvas{display:block;width:100%;height:100%;box-shadow:0 0 50px rgba(0,243,255,0.08)}

    /* HUD */
    .ui-layer{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;padding:clamp(8px,2.5vw,20px);box-sizing:border-box;z-index:5}
    .hud-top{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;font-size:clamp(11px,2.5vw,14px);text-shadow:0 0 5px var(--accent);font-weight:700;letter-spacing:1px;text-transform:uppercase;width:100%}
    .hud-panel{background:rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:6px;backdrop-filter:blur(4px);pointer-events:auto}
    .physics-controls{pointer-events:auto;display:flex;flex-direction:column;gap:6px;width:min(260px,44vw)}
    .slider-row label{font-size:11px;color:#aaa;margin-bottom:4px;display:flex;justify-content:space-between}

    .controls-hint{font-size:12px;opacity:0.75;text-align:right}

    .btn-info-corner{pointer-events:auto;position:absolute;right:4vw;top:4vw;background:rgba(0,0,0,0.6);border:1px solid var(--accent);color:var(--accent);padding:8px 14px;font-family:Orbitron, sans-serif;font-size:0.78rem;cursor:pointer;text-transform:uppercase;transition:all .2s;z-index:50}
    .btn-info-corner:hover{background:var(--accent);color:#000;box-shadow:0 0 15px var(--accent)}

    /* overlays */
    .overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(10,0,30,0.9),rgba(10,0,30,0.95)),linear-gradient(0deg,var(--retro-grid) 1px,transparent 1px),linear-gradient(90deg,var(--retro-grid) 1px,transparent 1px);background-size:100% 100%,40px 40px,40px 40px;backdrop-filter:blur(5px);display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:auto;transition:opacity .3s;z-index:10;box-shadow:inset 0 0 100px rgba(0,0,0,0.9);font-family:Orbitron, sans-serif}
    .hidden{opacity:0;pointer-events:none}

    .overlay h1{
      font-family:'Press Start 2P',cursive;
      /* Prefer wrapping between words; avoid breaking inside words */
      font-size:clamp(2rem,8.5vw,4.2rem);
      margin:0 0 18px 0;text-transform:uppercase;line-height:1.05;text-align:center;
      background:linear-gradient(to bottom,#fff 0%,var(--retro-highlight) 50%,var(--retro-pink) 51%,#9d00ff 100%);
      background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent;
      filter:drop-shadow(4px 4px 0px #000) drop-shadow(0 0 20px var(--retro-pink));
      transform:skew(-5deg);animation:flicker 3s infinite;display:block;max-width:calc(100% - 48px);
      /* prevent mid-word breaks */
      overflow-wrap:normal;word-break:normal;hyphens:none;white-space:normal;box-sizing:border-box;transform-origin:center;
      /* allow long words to scale down a bit rather than being hyphenated */
      -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
    }
    p.subtitle{font-family:Orbitron, sans-serif;font-size:clamp(0.95rem,4vw,1.6rem);color:var(--accent);margin-bottom:20px;letter-spacing:3px;text-transform:uppercase;text-shadow:0 0 10px var(--accent);border-top:2px solid var(--accent);border-bottom:2px solid var(--accent);padding:8px 14px;background:rgba(0,243,255,0.06);max-width:90vw;box-sizing:border-box}

    .name-input{background:#000;border:2px solid var(--retro-pink);color:var(--retro-highlight);padding:clamp(8px,2.5vw,16px);font-family:'Press Start 2P',cursive;font-size:clamp(0.95rem,4vw,1.6rem);margin-bottom:20px;text-align:center;width:min(600px,88vw);box-shadow:0 0 12px var(--retro-pink);outline:none;transition:all .18s;box-sizing:border-box}
    .name-input:focus{box-shadow:0 0 26px var(--retro-pink),inset 0 0 8px var(--retro-pink);border-color:#fff}
    .input-attention{animation:neonPulse 1.2s infinite alternate;border-color:var(--retro-highlight)!important;letter-spacing:2px}
    .input-error{animation:shake .4s ease-in-out;border-color:var(--danger)!important;box-shadow:0 0 20px var(--danger)!important}

    @keyframes neonPulse{0%,100%{color:var(--retro-highlight);text-shadow:0 0 20px var(--retro-highlight);opacity:1}50%{color:var(--retro-pink);text-shadow:0 0 5px var(--retro-pink);opacity:.7}}
    @keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-8px)}75%{transform:translateX(8px)}}

    .highscores{margin-top:18px;text-align:center;width:min(520px,92vw);background:rgba(0,0,0,0.85);border:2px solid #333;padding:8px;border-radius:6px;box-shadow:0 0 20px rgba(0,0,0,0.8);z-index:20;max-height:46vh;overflow-y:auto}
    .highscores::-webkit-scrollbar{width:8px}.highscores::-webkit-scrollbar-track{background:#000}.highscores::-webkit-scrollbar-thumb{background:var(--retro-pink);border-radius:6px}
    .hs-row{display:flex;justify-content:space-between;border-bottom:1px dotted #444;padding:8px 10px;font-family:'Press Start 2P',monospace;font-size:clamp(.7rem,2.2vw,.9rem);color:#ccc}
    .hs-row.header{color:var(--accent);text-shadow:0 0 5px var(--accent);margin-bottom:8px;border-bottom:2px solid var(--accent)}

    .info-content{width:min(820px,94vw);max-height:80vh;overflow-y:auto;background:rgba(0,0,0,0.88);border:2px solid var(--accent);padding:clamp(12px,3.5vw,28px);color:#e0e6ff;font-family:Segoe UI,Arial,Helvetica;line-height:1.6;box-sizing:border-box}
    .info-content h2{color:var(--retro-highlight);font-family:Orbitron, sans-serif;border-bottom:1px solid #444;margin-top:0;font-size:clamp(1rem,3.5vw,1.5rem)}
    .info-content h3{color:var(--accent);margin-top:14px;font-size:clamp(.95rem,2.8vw,1.1rem);text-transform:uppercase}
    .citation{margin-top:12px;padding:10px;background:rgba(255,255,255,0.03);border-left:3px solid var(--retro-pink);font-size:.9rem;color:#aaa}
    .close-btn{margin-top:12px;background:transparent;border:2px solid var(--retro-pink);color:var(--retro-pink);padding:8px 18px;cursor:pointer;font-family:Orbitron, sans-serif;float:right}
    .close-btn:hover{background:var(--retro-pink);color:#fff}

    .audio-select-label{font-size:clamp(.78rem,2.2vw,.95rem);color:#aaa;margin-bottom:8px;letter-spacing:2px}
    .audio-options{display:flex;gap:10px;margin-bottom:16px}
    .btn-audio{background:transparent;border:1px solid #555;color:#777;padding:8px 12px;cursor:pointer;font-family:Orbitron, sans-serif;font-size:.9rem}
    .btn-audio.active{border-color:var(--retro-highlight);color:var(--retro-highlight);box-shadow:0 0 12px var(--retro-highlight)}

    .btn-row{display:flex;gap:12px;margin-top:12px}
    button{font-family:Orbitron, sans-serif}

    button.btn-start{background:rgba(0,0,0,.86);color:var(--retro-highlight);font-size:clamp(1rem,3.3vw,1.4rem);padding:12px 28px;border:3px solid var(--retro-highlight);cursor:pointer;text-transform:uppercase;letter-spacing:2px;box-shadow:0 0 12px var(--retro-highlight)}
    button.btn-start:hover{background:var(--retro-highlight);color:#000}
    button.btn-secondary{background:transparent;color:#fff;font-size:.95rem;padding:10px 18px;border:2px solid #fff;cursor:pointer}

    .credits{margin-top:14px;font-family:Segoe UI,Arial;font-size:.82rem;color:rgba(255,255,255,0.65);text-align:center}
    .credits strong{color:var(--accent);display:block;font-size:.9rem;margin-bottom:6px}

    /* Small screens tweaks */
    @media (max-width:420px){
      .btn-info-corner{right:6vw;top:6vw;padding:8px 12px;font-size:.72rem}
      .hud-top{gap:8px}
      .overlay h1{margin-bottom:12px}
      .name-input{font-size:clamp(.9rem,5.5vw,1.1rem)}
      canvas{box-shadow:none}
    }

    /* Safe area support for devices with bottom/side UI (iPhone, etc.) */
    html{padding-top:env(safe-area-inset-top);padding-bottom:env(safe-area-inset-bottom);box-sizing:border-box}
    .ui-layer{padding-bottom:calc(clamp(8px,2.5vw,20px) + env(safe-area-inset-bottom));}
    .overlay{padding:calc(16px + env(safe-area-inset-top)) calc(12px + env(safe-area-inset-right)) calc(16px + env(safe-area-inset-bottom)) calc(12px + env(safe-area-inset-left));box-sizing:border-box;overflow:auto}

    /* Reduce title size on short viewports to avoid clipping */
    @media (max-height:700px){
      .overlay h1{font-size:clamp(1.8rem,2vw,3.2rem)}
      p.subtitle{font-size:clamp(.9rem,4vw,1.2rem)}
    }
  </style>
</head>
<body>

<div class="wrap">

  <canvas id="c"></canvas>
  <!-- Touch zones: top = UP, bottom = DOWN (mobile) -->
  <div class="touch-controls" id="touchControls" aria-hidden="true">
    <div class="touch-zone" id="touchUp"></div>
    <div class="touch-zone" id="touchDown"></div>
  </div>

  <div class="ui-layer">
    <div class="hud-top">
      <div class="hud-panel">SCORE: <span id="uiScore">0</span></div>
      <div class="hud-panel">SPEED: <span id="uiSpeed">0</span></div>
    
      <div class="hud-panel physics-controls">
        <div class="slider-row" style="display:none">
          <label><span>Dielectric (E<sub>r</sub>)</span> <span id="valPol">1.0</span></label>
          <input id="sliderPol" type="range" min="0" max="300" value="100">
        </div>
        
        <div class="slider-row">
           <div style="color:var(--text); font-size: 11px;">NET FORCE (Y): <span id="uiField" style="color:var(--accent)">0</span> N</div>
        </div>
      </div>
      
    </div>
    
    <div class="controls-hint">
      [SPACE] Start/Restart &nbsp;|&nbsp; [UP/DOWN] Hover &nbsp;|&nbsp; 
      <span style="color:#fff; text-shadow:0 0 5px #fff;">WHITE WALL = ATTRACTION TRAP</span>
    </div>
  </div>

  <div id="overlayStart" class="overlay">
    <h1>DIELECTRIC RUNNER</h1>
    <p class="subtitle">An Electrostatics Game</p>
    
    <button id="btnInfo" class="btn-info-corner">ABOUT</button>
    <input type="text" id="pName" class="name-input" placeholder="INSERT NAME" maxlength="8">
    
    <div class="audio-select-label">SOUND SYSTEM</div>
    <div class="audio-options">
        <button id="btnAudioRetro" class="btn-audio active">8-BIT CORE</button>
        <button id="btnAudioSpace" class="btn-audio">DEEP SPACE</button>
    </div>

    <button class="btn-start" id="btnStart">START</button>
    
    <div class="credits">
        <strong>Concept: Eric B. Lindgren</strong>
        Universidade Federal Fluminense<br>
        ericlindgren@id.uff.br<br>
        <a href="https://github.com/ericblindgren/dielectric-runner" target="_blank" style="color: inherit; text-decoration: underline; cursor: pointer;">
          https://github.com/ericblindgren/dielectric-runner
        </a> <br>
        v. 1.2 
    </div>
  </div>

  <div id="overlayGO" class="overlay hidden">
    <h1 style="font-size:5rem; margin-bottom: 0;">GAME OVER</h1>
    <p class="subtitle" style="color: var(--danger); text-shadow: 0 0 10px var(--danger);">COLLISION DETECTED</p>
    
    <div id="goScoreDisplay" style="font-family: 'Orbitron', sans-serif; font-size: 2.5rem; margin-bottom: 10px; letter-spacing: 2px;">
        FINAL SCORE: <span style="color: var(--accent); text-shadow: 0 0 10px var(--accent);">0</span>
    </div>
    
    <div class="highscores">
	  <div style="font-family: 'Press Start 2P', cursive; color: var(--retro-highlight); text-shadow: 0 0 15px var(--retro-highlight); font-size: 0.9rem; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #333; letter-spacing: 2px; text-transform: uppercase;">
		GLOBAL RANKING
	  </div>
		
      <div class="hs-row header"><span>#</span><span>PILOT</span><span>SCORE</span></div>
      <div id="hsList">
        <div class="hs-row" style="color:#777">CONNECTING TO DATABASE...</div>
      </div>
    </div>
    
    <div class="btn-row">
        <button class="btn-start" id="btnRetry">RETRY ('SPACE')</button>
        <button class="btn-secondary" id="btnNewPilot">QUIT</button>
    </div>
  </div>
  
  <div id="overlayInfo" class="overlay hidden" style="z-index: 100;">
      <div class="info-content">
          <h2>MISSION BRIEFING / ABOUT</h2>
          
          <h3>How to Play</h3>
          <ul>
              <li><strong>Controls:</strong> Use [UP] and [DOWN] arrows to hover vertically.</li>
              <li><strong>Objective:</strong> Navigate the tunnel without touching the walls. Distance traveled equals your score.</li>
              <li><strong>The Trap:</strong> Watch the wall color. <span style="color:#00f3ff; font-weight:bold;">Cyan</span> indicates a positively charged wall and <span style="color:#ff0055; font-weight:bold;">red</span> indicates a negatively charged wall. <span style="color:#ffffff; font-weight:bold;">WHITE</span> indicates an "Attraction Trap".</li> 
          </ul>

          <h3>Background Theory: Like-Charge Attraction</h3>
          <p>
              In classical electrostatics, two particles with the same charge sign repel each other according to Coulomb's Law. However, for finite-sized dielectric particles, the physics is far more complex.
          </p>
          <p>
              When charged dielectric particles approach, they induce surface charges on one another (polarization). If there is an asymmetry in the system, such as one particle being more highly charged or smaller than the other, the dominant particle exerts a strong polarizing influence. This induces a region of <em>opposite</em> charge on its neighbor.
          </p>
          <p>
              For like-charged particles, this geometry-dependent effect creates a short-range attractive force that can overcome the inherent Coulombic repulsion in some instances. In this game, getting too close to a positive wall with a high enough charge can trigger like-charge attraction, pulling your ship in right when you expect repulsion. Beware! If a <span style="color:#00f3ff; font-weight:bold;">cyan</span> wall turns <span style="color:#ffffff; font-weight:bold;">WHITE</span>, the interaction regime changes: repulsion becomes attraction.
          </p>

          <div class="citation">
              <strong>Reference:</strong><br>
              Lindgren, E. B. (2025). Charge-Induced Polarization in Dielectric Particle Systems: A Geometry-Dependent Effect. <em>Journal of Chemical Theory and Computation</em>, 21, 6135–6150.
          </div>
          
          <h3>License</h3>
			<p>
				Copyright (C) 2026 Eric B. Lindgren.
				This game is licensed under the GNU General Public License v3.0 or later.
				It comes with ABSOLUTELY NO WARRANTY.
			</p>
			<p>
				<a href="https://www.gnu.org/licenses/gpl-3.0.en.html" target="_blank" rel="license noopener noreferrer">GNU General Public License v3 (full text)</a>
			</p>
			
			<h3>Source Code</h3>
			<p>
			The complete corresponding source code for this game is available at:<br>
			<a href="https://github.com/ericblindgren/dielectric-runner"
				target="_blank"
				rel="noopener noreferrer">
				https://github.com/ericblindgren/dielectric-runner
			</a>
			</p>
			
			<h3>Third-Party Components</h3>
			<p>
				This game uses external libraries and fonts provided under their own licenses.
				These components are not covered by the GNU General Public License applied to this game.
			</p>

          <button id="btnCloseInfo" class="close-btn">CLOSE</button>
      </div>
  </div>
</div>

<script>
// ==========================================
// 1. FIREBASE SETUP
// ==========================================
const firebaseConfig = {
  apiKey: "AIzaSyCgE_ZUTphwarqUcOCjGEaohofZ5Cw5ntM",
  authDomain: "dielectric-runner.firebaseapp.com",
  projectId: "dielectric-runner",
  storageBucket: "dielectric-runner.firebasestorage.app",
  messagingSenderId: "442412282322",
  appId: "1:442412282322:web:aeab300f6b38df91ef180b",
  measurementId: "G-PJYH1ZWD7X"
};

let db = null;
try {
  firebase.initializeApp(firebaseConfig);
  analytics = firebase.analytics();
  db = firebase.firestore();
  console.log("Conectado ao Firebase Global!");
} catch (e) {
  console.warn("Erro ao conectar Firebase:", e);
}

function loadGlobalScores() {
  if (!db) return;
  const hsDiv = document.getElementById("hsList");
  hsDiv.innerHTML = "<div class='hs-row' style='color:#777'>LOADING GLOBAL DATA...</div>";

  // Limit to 20 for free tier safety
  db.collection("scores")
    .orderBy("score", "desc")
    .limit(20)
    .onSnapshot((snapshot) => {
      let html = "";
      let rank = 1;
      snapshot.forEach((doc) => {
        const data = doc.data();
        const safeName = escapeHtml(data.name);
        html += `
          <div class="hs-row">
            <span>#${rank}</span>
            <span>${safeName}</span>
            <span>${data.score}</span>
          </div>`;
        rank++;
      });
      hsDiv.innerHTML = html;
    }, (error) => {
      console.error("Erro leitura:", error);
      hsDiv.innerHTML = "<div class='hs-row' style='color:#f00'>DB ERROR</div>";
    });
}

function escapeHtml(text) {
  if (!text) return text;
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

// ==========================================
// 2. AUDIO ENGINE
// ==========================================
class AudioSys {
  constructor() {
    this.ctx = null;
    this.master = null;
    this.noiseBuffer = null;
    this.nextNoteTime = 0;
    this.noteIndex = 0;
    this.mode = 'retro'; 
    this.tempoRetro = 0.13;
    this.tempoSpace = 2.0; 
    this.tempoMenu = 3.0;
    this.scaleRetro = [110.00, 130.81, 146.83, 164.81, 196.00, 220.00]; 
    this.spaceNotes = [55, 65.41, 73.42, 82.41, 98, 110, 130.81]; 
    this.menuNotes = [220.00, 329.63, 392.00, 493.88, 587.33]; 
    this.droneOsc = null;
    this.droneGain = null;
    this.isPlaying = false;
  }

  setMode(m) { this.mode = m; }

  init() {
    if (this.ctx) return; 
    try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return; 
        
        this.ctx = new Ctx();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.4; 
        this.master.connect(this.ctx.destination);
        
        const bufSize = this.ctx.sampleRate * 2; 
        this.noiseBuffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const delay = this.ctx.createDelay();
        delay.delayTime.value = 0.4;
        const delayFb = this.ctx.createGain();
        delayFb.gain.value = 0.4;
        const delayFilter = this.ctx.createBiquadFilter();
        delayFilter.frequency.value = 1500; 
        
        this.master.connect(delay);
        delay.connect(delayFilter);
        delayFilter.connect(delayFb);
        delayFb.connect(delay);
        delay.connect(this.ctx.destination);
        
        this.delayNode = delay;
        this.delayFbNode = delayFb;
    } catch(e) {}
  }
  
  updateDelaySettings(active) {
      if(!this.delayNode) return;
      try {
        if (!active) {
            this.delayNode.delayTime.rampToValueAtTime(0.45, this.ctx.currentTime + 1);
            this.delayFbNode.gain.rampToValueAtTime(0.6, this.ctx.currentTime + 1);
        } else if (this.mode === 'space') {
            this.delayNode.delayTime.rampToValueAtTime(0.6, this.ctx.currentTime + 1);
            this.delayFbNode.gain.rampToValueAtTime(0.6, this.ctx.currentTime + 1);
        } else {
            this.delayNode.delayTime.rampToValueAtTime(0.25, this.ctx.currentTime + 1);
            this.delayFbNode.gain.rampToValueAtTime(0.3, this.ctx.currentTime + 1);
        }
      } catch(e) {}
  }
  
  updateDrone(active) {
      if (!this.ctx) return;
      const t = this.ctx.currentTime;
      if (!active && !this.droneOsc) {
          this.droneOsc = this.ctx.createOscillator();
          this.droneOsc.type = 'sawtooth';
          this.droneOsc.frequency.value = 55.00; 
          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 90; 
          this.droneGain = this.ctx.createGain();
          this.droneGain.gain.setValueAtTime(0, t);
          this.droneGain.gain.linearRampToValueAtTime(0.2, t + 3.0); 
          this.droneOsc.connect(filter);
          filter.connect(this.droneGain);
          this.droneGain.connect(this.master);
          this.droneOsc.start(t);
      } else if (active && this.droneOsc) {
          this.droneGain.gain.cancelScheduledValues(t);
          this.droneGain.gain.setValueAtTime(this.droneGain.gain.value, t);
          this.droneGain.gain.exponentialRampToValueAtTime(0.001, t + 1.0); 
          this.droneOsc.stop(t + 1.1);
          this.droneOsc = null;
          this.droneGain = null;
      }
  }

  resume() { try { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); } catch(e) {} }

  playBGM() {
    if (!this.ctx || !this.isPlaying) return;
    try {
        this.updateDrone(State.active);
        let currentTempo = (!State.active) ? this.tempoMenu : (this.mode === 'space' ? this.tempoSpace : this.tempoRetro);
        
        while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
          if (!State.active) this.triggerMenuNote(this.nextNoteTime);
          else if (this.mode === 'space') this.triggerSpaceNote(this.nextNoteTime);
          else this.triggerRetroNote(this.nextNoteTime);
          this.nextNoteTime += currentTempo;
        }
        if (this.ctx.currentTime % 2 < 0.1) this.updateDelaySettings(State.active);
    } catch(e) {}
  }

  triggerMenuNote(t) {
    const note = this.menuNotes[this.noteIndex % this.menuNotes.length];
    const octave = Math.random() > 0.6 ? 2 : 1; 
    const osc = this.ctx.createOscillator();
    osc.type = 'sine'; osc.frequency.value = note * octave;
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.08, t + 0.1); 
    gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0); 
    osc.connect(gain); gain.connect(this.master);
    osc.start(t); osc.stop(t + 2.5); this.noteIndex++;
  }

  triggerRetroNote(t) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const pattern = [0, 2, 3, 5, 7, 5, 3, 2, 0, 0, -3, 0, 2, 0, -3, -5];
    const idx = this.noteIndex % pattern.length;
    let noteIdx = pattern[idx];
    let freq = (noteIdx >= 0) ? this.scaleRetro[noteIdx % this.scaleRetro.length] * (1 + Math.floor(noteIdx/this.scaleRetro.length)) : this.scaleRetro[0]/2;
    osc.frequency.value = freq;
    
    if (idx % 4 === 0) {
      osc.type = 'sawtooth'; gain.gain.setValueAtTime(0.15, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
    } else {
      osc.type = 'square'; gain.gain.setValueAtTime(0.05, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    }
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass'; filter.frequency.setValueAtTime(800, t); filter.frequency.linearRampToValueAtTime(100, t + 0.2);
    osc.connect(filter); filter.connect(gain); gain.connect(this.master);
    osc.start(t); osc.stop(t + 0.4); this.noteIndex++;
  }

  triggerSpaceNote(t) {
    const freq = this.spaceNotes[Math.floor(Math.random() * this.spaceNotes.length)];
    const octave = Math.random() > 0.7 ? 2 : 1;
    const carrier = this.ctx.createOscillator(); carrier.type = 'sine'; carrier.frequency.value = freq * octave;
    const modulator = this.ctx.createOscillator(); modulator.type = 'triangle'; modulator.frequency.value = freq * 2.02; 
    const modGain = this.ctx.createGain(); modGain.gain.value = 100; 
    modulator.connect(modGain); modGain.connect(carrier.frequency);
    const masterGain = this.ctx.createGain();
    masterGain.gain.setValueAtTime(0, t); masterGain.gain.linearRampToValueAtTime(0.2, t + 0.5); masterGain.gain.exponentialRampToValueAtTime(0.001, t + 2.5); 
    carrier.connect(masterGain); masterGain.connect(this.master);
    carrier.start(t); carrier.stop(t + 3.0); modulator.start(t); modulator.stop(t + 3.0);
    this.noteIndex++;
  }

  sfxThrust() {
    if (!this.ctx) return;
    try {
        const t = this.ctx.currentTime;
        const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuffer;
        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 600; 
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.08, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15); 
        src.connect(filter); filter.connect(gain); gain.connect(this.master);
        src.start(t); src.stop(t + 0.2);
    } catch(e){}
  }

  sfxCrash() {
    if (!this.ctx) return;
    try {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        osc.connect(gain); gain.connect(this.master);
        osc.start(t); osc.stop(t+0.6);
    } catch(e){}
  }

  startMusic() { 
      try {
        if (!this.ctx) this.init(); 
        this.isPlaying = true; 
        if(this.ctx) {
            if (this.nextNoteTime < this.ctx.currentTime) this.nextNoteTime = this.ctx.currentTime + 0.1; 
            this.updateDelaySettings(State.active);
        }
      } catch(e) {}
  }
}

// ==========================================
// 3. GAME ENGINE
// ==========================================
const Audio = new AudioSys();
const btnRetro = document.getElementById('btnAudioRetro');
const btnSpace = document.getElementById('btnAudioSpace');

if (btnRetro && btnSpace) {
    btnRetro.addEventListener('click', () => { Audio.setMode('retro'); btnRetro.classList.add('active'); btnSpace.classList.remove('active'); });
    btnSpace.addEventListener('click', () => { Audio.setMode('space'); btnSpace.classList.add('active'); btnRetro.classList.remove('active'); });
}

window.addEventListener('click', () => {
   if (!Audio.ctx) { Audio.init(); Audio.resume(); Audio.startMusic(); }
}, { once: true });

const CFG = {
  W: 1200, H: 800, GRAVITY: 0, THRUST: 600, DRAG: 2.0, SCROLL_V0: 150, SCROLL_ACCEL: 8,
  SEG_LEN: 300, WALL_GAP: 500, K_COULOMB: 80, K_LIKE_BASE: 15.0, DIELECTRIC_MULT: 1.0, 
  DIST_SCALE: 100, ISO_ANGLE: 0.6, FOV: 600
};

const State = {
  active: false, paused: false, over: false, time: 0, score: 0, distance: 0, speed: CFG.SCROLL_V0,
  player: { y: 0, vy: 0, q: 1 }, trail: [], segments: [], particles: [], forces: { topC:0, topP:0, botC:0, botP:0 }
};

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let bounds = { w: 0, h: 0 };
let _resizeTimeout = null;
let safeInsets = { left: 0, right: 0, top: 0, bottom: 0 };
function resize() {
  if (!canvas || !ctx) return;
  if (_resizeTimeout) clearTimeout(_resizeTimeout);
  _resizeTimeout = setTimeout(() => {
    // Prefer visualViewport when available (handles mobile UI chrome)
    const vw = window.visualViewport ? window.visualViewport.width : window.innerWidth;
    const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;
    const w = Math.max(1, Math.floor(vw));
    const h = Math.max(1, Math.floor(vh));
    bounds.w = w; bounds.h = h;

    // CSS size (CSS pixels)
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';

    // Backing buffer size (account for devicePixelRatio for crisp rendering)
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.max(1, Math.floor(w * dpr));
    canvas.height = Math.max(1, Math.floor(h * dpr));

    // Scale drawing operations to CSS pixels
    try { ctx.setTransform(dpr, 0, 0, dpr, 0, 0); } catch (e) { }
    // Update game configuration to fit the viewport (prevents wall clipping on small devices)
    try {
      CFG.W = bounds.w;
      CFG.H = bounds.h;
      // Keep wall gap proportional to viewport height but clamped
      CFG.WALL_GAP = Math.max(180, Math.floor(bounds.h * 0.6));
      // Segment length scaled to viewport width for consistent pacing
      CFG.SEG_LEN = Math.max(180, Math.floor(bounds.w * 0.5));

      // Ensure player stays inside new wall gap immediately after resize
      if (State && State.player) {
        State.player.y = Math.max(Math.min(State.player.y, CFG.WALL_GAP/2 - 30), -CFG.WALL_GAP/2 + 30);
      }
      // Measure CSS safe-area insets (via computed padding using env()) so we can offset canvas drawing
      try {
        const measureInset = (prop) => {
          const el = document.createElement('div');
          el.style.position = 'absolute'; el.style.visibility = 'hidden'; el.style.pointerEvents = 'none';
          // apply padding using env()
          el.style.padding = `env(safe-area-inset-${prop})`;
          document.body.appendChild(el);
          const cs = getComputedStyle(el);
          let val = 0;
          if (prop === 'left' || prop === 'right') val = parseFloat(cs.paddingLeft) || 0;
          else val = parseFloat(cs.paddingTop) || 0;
          document.body.removeChild(el);
          return val;
        };
        safeInsets.left = measureInset('left');
        safeInsets.right = measureInset('right');
        safeInsets.top = measureInset('top');
        safeInsets.bottom = measureInset('bottom');
      } catch (e) { safeInsets = { left:0,right:0,top:0,bottom:0 }; }
    } catch (e) {}
  }, 50);
}
window.addEventListener('resize', resize);
if (window.visualViewport) window.visualViewport.addEventListener('resize', resize);
resize();

const Input = { up: false, down: false };
window.addEventListener('keydown', e => {
  if(e.code === 'Space') handleSpace();
  if(e.code === 'ArrowUp' || e.code === 'KeyW') Input.up = true;
  if(e.code === 'ArrowDown' || e.code === 'KeyS') Input.down = true;
});
window.addEventListener('keyup', e => {
  if(e.code === 'ArrowUp' || e.code === 'KeyW') Input.up = false;
  if(e.code === 'ArrowDown' || e.code === 'KeyS') Input.down = false;
});

// ==========================================
// TOUCH CONTROLS IMPLEMENTATION
// ==========================================
let touchStartY = 0;
const TOUCH_THRESHOLD = 10; // Sensitivity (pixels)

window.addEventListener('touchstart', e => {
  if (e.target.tagName === 'CANVAS') e.preventDefault();

  // Handle Game Start / Restart on Tap
  if ((!State.active || State.over) && overlayInfo.classList.contains('hidden')) {
      Input.up = false;
      Input.down = false;
      if (e.target.tagName === 'CANVAS') handleSpace(); 
      return;
  }

  // Set Reference Point
  if (e.touches.length > 0) {
    touchStartY = e.touches[0].clientY;
    Input.up = false;
    Input.down = false;
  }
}, { passive: false });

window.addEventListener('touchmove', e => {
  if (e.target.tagName === 'CANVAS' || State.active) e.preventDefault();
  if (!State.active || e.touches.length === 0) return;

  const currentY = e.touches[0].clientY;
  const delta = currentY - touchStartY;

  Input.up = false;
  Input.down = false;

  if (delta < -TOUCH_THRESHOLD) Input.up = true; // Sliding Up
  else if (delta > TOUCH_THRESHOLD) Input.down = true; // Sliding Down
}, { passive: false });

window.addEventListener('touchend', e => {
  Input.up = false;
  Input.down = false;
});

const uiScore = document.getElementById('uiScore');
const uiSpeed = document.getElementById('uiSpeed');
const uiField = document.getElementById('uiField');
const sliderPol = document.getElementById('sliderPol');
const valPol = document.getElementById('valPol');
const overlayStart = document.getElementById('overlayStart');
const overlayGO = document.getElementById('overlayGO');
const overlayInfo = document.getElementById('overlayInfo');
const btnStart = document.getElementById('btnStart');
const btnRetry = document.getElementById('btnRetry');
const btnNewPilot = document.getElementById('btnNewPilot');
const btnInfo = document.getElementById('btnInfo');
const btnCloseInfo = document.getElementById('btnCloseInfo');
const pNameInput = document.getElementById('pName');

// NAME FILTER: No Spaces, Lowercase
pNameInput.addEventListener('input', function(e) {
  let val = e.target.value;
  val = val.toLowerCase();
  val = val.replace(/\s/g, ''); 
  e.target.value = val;
});

sliderPol.addEventListener('input', (e) => {
  const val = parseFloat(e.target.value) / 100;
  CFG.DIELECTRIC_MULT = val; valPol.innerText = val.toFixed(2);
});

btnInfo.addEventListener('click', () => {
    overlayInfo.classList.remove('hidden');
    if (State.active) { State.active = false; State.paused = true; }
});
btnCloseInfo.addEventListener('click', () => {
    overlayInfo.classList.add('hidden');
    if (State.paused) { State.active = true; State.paused = false; }
});

const defaultText = "INSERT NAME";
const savedName = localStorage.getItem("ion_runner_name");

// 1. Initialize Input
if (savedName && savedName !== "guest") {
    // If we have a real player name saved, show it normally
    pNameInput.value = savedName;
} else {
    // Otherwise, show the blinking prompt
    pNameInput.value = defaultText;
    pNameInput.classList.add('input-attention');
}

// 2. Clear on Click (Focus)
pNameInput.addEventListener('focus', () => {
    if (pNameInput.value === defaultText) {
        pNameInput.value = "";
        pNameInput.classList.remove('input-attention');
    }
});

// 3. Restore if Left Empty (Blur)
pNameInput.addEventListener('blur', () => {
    if (pNameInput.value.trim() === "") {
        pNameInput.value = defaultText;
        pNameInput.classList.add('input-attention');
    }
});

function handleSpace() {
  if (!overlayInfo.classList.contains('hidden')) return;
  // SPACE ONLY RESTARTS GAME
  if (State.over) resetGame();
}

btnStart.addEventListener('click', startGame);
btnRetry.addEventListener('click', resetGame);
btnNewPilot.addEventListener('click', goToMenu);

function startGame() {
  const val = pNameInput.value;
  
  if (!val || val.trim() === "" || val === defaultText) {
    // Trigger Shake Effect
    pNameInput.classList.add('input-error');
    // Remove class after 400ms so it can be triggered again
    setTimeout(() => pNameInput.classList.remove('input-error'), 400);
    pNameInput.focus();
    return; // STOP THE GAME FROM STARTING
  }

  if (pNameInput) localStorage.setItem("ion_runner_name", pNameInput.value);
  try { if(!Audio.ctx) Audio.init(); Audio.resume(); Audio.startMusic(); } catch (e) {}
  overlayStart.classList.add('hidden');
  resetPhysics();
  State.active = true; State.over = false; State.paused = false;
}

function resetGame() {
  overlayGO.classList.add('hidden');
  resetPhysics();
  State.active = true; State.over = false;
  try { Audio.startMusic(); } catch(e){}
}

function goToMenu() {
    overlayGO.classList.add('hidden'); 
    overlayStart.classList.remove('hidden');
    pNameInput.value = ""; 
    pNameInput.focus();
    
    State.active = false; 
    State.paused = false;
    State.over = false;
}

function resetPhysics() {
  State.time = 0; State.score = 0; State.distance = 0; State.speed = CFG.SCROLL_V0;
  State.player.y = 0; State.player.vy = 0;
  State.segments = []; State.particles = []; State.trail = [];
  State.forces = { topC:0, topP:0, botC:0, botP:0 };
  for(let i=0; i<10; i++) addSegment(i * CFG.SEG_LEN);
}

function addSegment(x) {
  const isSafe = x < 600; 
  const progression = Math.floor(State.distance / 3000);
  const qMax = Math.min(30, 10 + progression * 2);
  const getMag = () => Math.floor(Math.random() * (qMax - 1)) + 1; 
  let qTop = isSafe ? 0 : (Math.random() > 0.5 ? 1 : -1) * getMag();
  let qBot = isSafe ? 0 : (Math.random() > 0.5 ? 1 : -1) * getMag();
  if(Math.random() < 0.25 && !isSafe) qTop = Math.abs(qTop) * 1.5; 
  State.segments.push({ x: x, w: CFG.SEG_LEN, qTop, qBot });
}

function update(dt) {
  State.time += dt; State.speed += CFG.SCROLL_ACCEL * dt; State.distance += State.speed * dt;
  State.score = Math.floor(State.distance / 10);
  
  const lastSeg = State.segments[State.segments.length-1];
  if (lastSeg.x < State.distance + bounds.w + 500) addSegment(lastSeg.x + CFG.SEG_LEN);
  if (State.segments[0].x + CFG.SEG_LEN < State.distance - 1000) State.segments.shift();
  
  const p = State.player;
  const currSeg = State.segments.find(s => s.x <= State.distance + 200 && s.x + CFG.SEG_LEN > State.distance + 200) || State.segments[0];
  
  let thrust = 0;
  if (Input.up) thrust -= CFG.THRUST;
  if (Input.down) thrust += CFG.THRUST;
  
  const distScale = CFG.DIST_SCALE;
  const dTop = (p.y - (-CFG.WALL_GAP/2));
  const dBot = ((CFG.WALL_GAP/2) - p.y);
  const dtS = Math.max(5, dTop) / distScale;
  const dbS = Math.max(5, dBot) / distScale;
  
  const K_LIKE = CFG.K_LIKE_BASE * CFG.DIELECTRIC_MULT;
  
  const F_Top_C = (CFG.K_COULOMB * currSeg.qTop) / (dtS*dtS);
  const F_Top_P = (K_LIKE * currSeg.qTop*currSeg.qTop) / (dtS*dtS*dtS);
  const F_Top = F_Top_C - F_Top_P; 

  const F_Bot_C = (CFG.K_COULOMB * currSeg.qBot) / (dbS*dbS); 
  const F_Bot_P = (K_LIKE * currSeg.qBot*currSeg.qBot) / (dbS*dbS*dbS);
  const F_Bot_Net = -( (CFG.K_COULOMB * currSeg.qBot) / (dbS*dbS) ) + F_Bot_P;
  
  const totalAy = CFG.GRAVITY + thrust + F_Top + F_Bot_Net;
  
  State.forces.topC = Math.abs(F_Top_C); State.forces.topP = Math.abs(F_Top_P);
  State.forces.botC = Math.abs(F_Bot_C); State.forces.botP = Math.abs(F_Bot_P);
  
  p.vy += totalAy * dt;
  p.vy *= Math.exp(-CFG.DRAG * dt);
  p.y += p.vy * dt;

  State.trail.push({ x: State.distance + 200, y: p.y });
  if (State.trail.length > 100) State.trail.shift();

  if (Input.up || Input.down) {
    if (Math.random() < 0.6) {
      const exhaustDir = Input.up ? 1 : -1; 
      State.particles.push({
        x: State.distance + 200, y: p.y, vx: -State.speed - Math.random()*50, 
        vy: exhaustDir * (100 + Math.random()*100), life: 0.8, color: Input.up ? '#0ff' : '#f0f' 
      });
      Audio.sfxThrust();
    }
  }
  
  for (let i=State.particles.length-1; i>=0; i--) {
    let pt = State.particles[i]; pt.x += pt.vx * dt; pt.y += pt.vy * dt; pt.life -= dt * 2.5; 
    if (pt.life <= 0) State.particles.splice(i, 1);
  }
  
  if (p.y < -CFG.WALL_GAP/2 + 20 || p.y > CFG.WALL_GAP/2 - 20) gameOver();

  uiScore.innerText = State.score; uiSpeed.innerText = Math.floor(State.speed);
  const netF = (F_Top + F_Bot_Net);
  uiField.innerText = netF.toFixed(0); uiField.style.color = Math.abs(netF) > 1000 ? '#ff0055' : '#00f3ff';
}

function gameOver() {
  State.active = false; State.over = true;
  Audio.sfxCrash();
  
  const finalScore = State.score;
  const pilotName = pNameInput.value.trim() || "pilot";
  
  document.getElementById('goScoreDisplay').innerHTML = `FINAL SCORE: <span style="color: var(--accent); text-shadow: 0 0 10px var(--accent);">${finalScore}</span>`;

  overlayGO.classList.remove('hidden');
  loadGlobalScores();

  if (db && finalScore > 0) {
    db.collection("scores").add({
      name: pilotName,
      score: finalScore,
      date: firebase.firestore.FieldValue.serverTimestamp()
    })
    .then(() => { console.log("Pontuação salva!"); })
    .catch((error) => { 
        // Log técnico no console para debug
        console.error("Database Write Error:", error); 
        
        alert("Error: Score submission failed.");
        
        // Volta ao menu para tentar novamente
        goToMenu();
    });
  }
}

// ==========================================
// 4. RENDERER
// ==========================================
function render() {
  ctx.fillStyle = "#050510";
  ctx.fillRect(0, 0, bounds.w, bounds.h);

  // Compute drawable area inside safe-area insets so nothing is drawn under OS/browser chrome
  const drawW = Math.max(1, bounds.w - (safeInsets.left + safeInsets.right));
  const drawH = Math.max(1, bounds.h - (safeInsets.top + safeInsets.bottom));
  const cx = safeInsets.left + drawW / 2;
  const cy = safeInsets.top + drawH / 2;
  
  // Grid (constrained to drawable area)
  ctx.save();
  ctx.strokeStyle = "rgba(0, 243, 255, 0.1)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  const gridOff = -(State.distance % 100);
  for(let i=0; i<drawW/100 + 2; i++){
    let gx = safeInsets.left + i*100 + gridOff;
    ctx.moveTo(gx, safeInsets.top); ctx.lineTo(gx, safeInsets.top + drawH);
  }
  for(let i=0; i<drawH/100; i++){
    ctx.moveTo(safeInsets.left, safeInsets.top + i*100); ctx.lineTo(safeInsets.left + drawW, safeInsets.top + i*100);
  }
  ctx.stroke();
  ctx.restore();

  // Identify current segment
  const currentSegment = State.segments.find(s => s.x <= State.distance + 200 && s.x + CFG.SEG_LEN > State.distance + 200) || State.segments[0];

  // Walls
  const wallDepth = 60; 
  const viewTilt = 0.4; 
  
  if (State.segments.length > 0) {
      State.segments.forEach(s => {
        const baseX = safeInsets.left; // offset so drawing stays inside safe area
        const x1 = baseX + (s.x - State.distance) + 200; 
        const x2 = baseX + (s.x + CFG.SEG_LEN - State.distance) + 200;

        if (x2 < safeInsets.left - 300 || x1 > safeInsets.left + drawW + 100) return;

        const yTop = safeInsets.top + drawH/2 - CFG.WALL_GAP/2;
        const yBot = safeInsets.top + drawH/2 + CFG.WALL_GAP/2;
        const hWall = 200;
        
        const isActiveSegment = (s === currentSegment);

        const getC = (q) => {
          if (q === 0) return [60, 60, 70];
          if (q > 0) return [0, 243, 255]; 
          return [255, 0, 85];             
        };
        
        const drawBlock = (yBase, h, q, isCeiling) => {
          let c = getC(q);
          let intensity = Math.min(1, Math.abs(q)/10); 
          let alpha = (q === 0) ? 0.8 : (0.3 + 0.7*intensity);
          
          let isLCA = false;
          if (isActiveSegment && q > 0) {
              if (isCeiling) { if (State.forces.topP > State.forces.topC) isLCA = true; } 
              else { if (State.forces.botP > State.forces.botC) isLCA = true; }
          }

          let colStr;
          if (isLCA) { colStr = "rgba(255, 255, 255, 1.0)"; alpha = 1.0; } 
          else { colStr = `rgba(${c[0]},${c[1]},${c[2]},${alpha})`; }

          const offX = wallDepth; 
          const offY = isCeiling ? wallDepth * viewTilt : -wallDepth * viewTilt;
          const yEdge = yBase;
          const yFar = isCeiling ? yBase - h : yBase + h;
          
          // Draw 3D side
          ctx.beginPath();
          ctx.moveTo(x1, yEdge);
          ctx.lineTo(x2, yEdge);
          ctx.lineTo(x2 + offX, yEdge + offY);
          ctx.lineTo(x1 + offX, yEdge + offY);
          ctx.closePath();
          if (isLCA) ctx.fillStyle = "#ccc"; 
          else ctx.fillStyle = `rgba(${c[0]*0.5},${c[1]*0.5},${c[2]*0.5},${alpha})`; 
          ctx.fill();
          ctx.strokeStyle = colStr; ctx.lineWidth = 1; ctx.stroke();

          // Draw Front Face
          ctx.beginPath();
          ctx.moveTo(x1, yEdge);
          ctx.lineTo(x2, yEdge);
          ctx.lineTo(x2, yFar);
          ctx.lineTo(x1, yFar);
          ctx.closePath();
          
          if (Math.abs(q) > 0) {
            ctx.shadowBlur = isLCA ? 40 : (20 + Math.abs(q)*2);
            ctx.shadowColor = colStr;
          }
          
          if (isLCA) ctx.fillStyle = "#fff";
          else ctx.fillStyle = `rgba(${c[0]*0.2},${c[1]*0.2},${c[2]*0.2}, 0.9)`; 
          
          ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
          
          if (Math.abs(q) > 0) {
            ctx.fillStyle = isLCA ? "#000" : "#fff";
            ctx.font = "bold 20px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(q > 0 ? "+" + q.toFixed(0) : q.toFixed(0), (x1+x2)/2, (yEdge + yFar)/2);
          }
        };
        drawBlock(yTop, hWall, s.qTop, true);
        drawBlock(yBot, hWall, s.qBot, false);
      });
  }

  // Trail
  if (State.trail.length > 1) {
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.shadowBlur = 10;
    ctx.shadowColor = "#00f3ff";
    ctx.strokeStyle = "rgba(0, 243, 255, 0.2)"; 
    ctx.lineWidth = 6;
    for (let i = 0; i < State.trail.length; i++) {
      const p = State.trail[i];
      const sx = safeInsets.left + (p.x - State.distance);
      const sy = safeInsets.top + drawH/2 + p.y;
      if(i===0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    ctx.lineWidth = 3;
    for (let i = 1; i < State.trail.length; i++) {
      const p1 = State.trail[i-1];
      const p2 = State.trail[i];
      const sx1 = safeInsets.left + (p1.x - State.distance);
      const sy1 = safeInsets.top + drawH/2 + p1.y;
      const sx2 = safeInsets.left + (p2.x - State.distance);
      const sy2 = safeInsets.top + drawH/2 + p2.y;
      const alpha = (i / State.trail.length);
      ctx.beginPath();
      ctx.moveTo(sx1, sy1);
      ctx.lineTo(sx2, sy2);
      ctx.strokeStyle = `rgba(0, 243, 255, ${alpha})`; 
      ctx.stroke();
    }
    ctx.restore();
  }

  // Particles
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for(let p of State.particles) {
    const ppx = safeInsets.left + (p.x - State.distance); 
    const ppy = safeInsets.top + drawH/2 + p.y;
    if (ppx < -50 || ppx > bounds.w + 50) continue;

    ctx.beginPath();
    ctx.arc(ppx, ppy, 3*p.life, 0, Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life;
    ctx.fill();
  }
  ctx.restore();
  
  // PLAYER RENDER
  const px = safeInsets.left + 200; 
  const py = safeInsets.top + drawH/2 + State.player.y;
  
  ctx.save();
  
  ctx.shadowBlur = 20;
  ctx.shadowColor = "#fff";
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(px, py, 10, 0, Math.PI*2);
  ctx.fill();
  
  ctx.shadowBlur = 40;
  ctx.shadowColor = "#00f3ff";
  ctx.strokeStyle = "#00f3ff";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(px, py, 16 + Math.sin(Date.now()/100)*2, 0, Math.PI*2);
  ctx.stroke();
  
  ctx.shadowBlur = 0;
  ctx.fillStyle = "#000";
  ctx.font = "bold 12px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("+1", px, py);
  
  ctx.restore();
}

function loop() {
  const now = performance.now();
  const dt = Math.min(0.05, (now - (State.lastTime || now)) / 1000);
  State.lastTime = now;
  
  if (State.active) update(dt);
  
  Audio.playBGM();
  render();
  requestAnimationFrame(loop);
}

// Initial physics setup (so menu isn't empty)
resetPhysics();
loop();
</script>
</body>
</html>
