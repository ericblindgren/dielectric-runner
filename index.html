<!doctype html>
<html lang="en">
<!--
Dielectric Runner - An Electrostatics Game
Copyright (C) 2026 Eric B. Lindgren

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the LICENSE file (GPLv3) for details.
-->
<!-- SPDX-License-Identifier: GPL-3.0-or-later -->
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dielectric Runner</title>
  
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Crect width='16' height='16' fill='%23050510'/%3E%3Cpath d='M2 8c2-4 4-4 6 0s4 4 6 0' fill='none' stroke='%2300f3ff' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Press+Start+2P&display=swap" rel="stylesheet">

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

  <style>
    /* --- AESTHETICS --- */
    :root {
      --bg: #050510;
      --ui-bg: rgba(10, 10, 20, 0.85);
      --accent: #00f3ff;
      --danger: #ff0055;
      --text: #e0e6ff;
      --lca-white: #ffffff;
      --retro-pink: #ff00de;
      --retro-purple: #9d00ff;
      --retro-highlight: #ff3300; 
      --retro-grid: rgba(255, 0, 222, 0.15);
    }
    
    @keyframes flicker {
      0%, 18%, 22%, 25%, 53%, 57%, 100% { opacity: 1; transform: skew(-5deg) scale(1); }
      20%, 24%, 55% { opacity: 0.5; transform: skew(-5deg) scale(0.98); }
    }
    
    html, body {
      height: 100%; margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }
    body { display: grid; place-items: center; }
    
    .wrap {
      position: relative;
      width: 100%; height: 100%;
      display: flex; justify-content: center; align-items: center;
      background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
    }
    canvas { display: block; box-shadow: 0 0 50px rgba(0, 243, 255, 0.1); }
    
    /* HUD & UI */
    .ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 20px; box-sizing: border-box; z-index: 5;
    }
    .hud-top {
      display: flex; gap: 20px; align-items: flex-start;
      font-size: 14px; text-shadow: 0 0 5px var(--accent);
      font-weight: 700; letter-spacing: 1px; text-transform: uppercase;
      width: 100%;
    }
    .hud-panel {
      background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.1);
      padding: 8px 16px; border-radius: 4px; backdrop-filter: blur(4px);
    }
    .physics-controls { pointer-events: auto; display: flex; flex-direction: column; gap: 5px; width: 240px; }
    .slider-row { display: flex; flex-direction: column; }
    .slider-row label { font-size: 11px; color: #aaa; margin-bottom: 4px; display: flex; justify-content: space-between; }
    input[type=range] { width: 100%; cursor: pointer; accent-color: var(--accent); }
    .controls-hint { font-size: 12px; opacity: 0.7; text-align: right; }
    .tooltip { font-size: 10px; color: #777; margin-top: 4px; line-height: 1.2; }

    .btn-info-corner {
        pointer-events: auto; position: absolute; right: 20px; top: 20px;
        background: rgba(0, 0, 0, 0.6); border: 1px solid var(--accent); color: var(--accent);
        padding: 10px 20px; font-family: 'Orbitron', sans-serif; font-size: 0.8rem;
        cursor: pointer; text-transform: uppercase; transition: all 0.2s; z-index: 50;
    }
    .btn-info-corner:hover { background: var(--accent); color: #000; box-shadow: 0 0 15px var(--accent); }

    /* OVERLAYS */
    .overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: 
        linear-gradient(rgba(10, 0, 30, 0.9), rgba(10, 0, 30, 0.95)),
        linear-gradient(0deg, var(--retro-grid) 1px, transparent 1px),
        linear-gradient(90deg, var(--retro-grid) 1px, transparent 1px);
      background-size: 100% 100%, 40px 40px, 40px 40px;
      backdrop-filter: blur(5px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      pointer-events: auto; transition: opacity 0.3s ease; z-index: 10;
      box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
      font-family: 'Orbitron', sans-serif;
    }
    .hidden { opacity: 0; pointer-events: none; }
    
    .overlay h1 {
      font-family: 'Press Start 2P', cursive; font-size: 5.0rem; margin: 0 0 30px 0;
      text-transform: uppercase; line-height: 1.2; text-align: center;
      background: linear-gradient(to bottom, #fff 0%, var(--retro-highlight) 50%, var(--retro-pink) 51%, var(--retro-purple) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      filter: drop-shadow(4px 4px 0px #000) drop-shadow(0 0 20px var(--retro-pink));
      transform: skew(-5deg); animation: flicker 3s infinite;
    }
    p.subtitle {
      font-family: 'Orbitron', sans-serif; font-size: 2.0rem; color: var(--accent);
      margin-bottom: 30px; letter-spacing: 4px; text-transform: uppercase;
      text-shadow: 0 0 10px var(--accent); border-top: 2px solid var(--accent);
      border-bottom: 2px solid var(--accent); padding: 10px 20px; background: rgba(0, 243, 255, 0.1);
    }
    
    .name-input {
      background: #000; border: 2px solid var(--retro-pink); color: var(--retro-highlight);
      padding: 20px; font-family: 'Press Start 2P', cursive; font-size: 1.8rem;
      margin-bottom: 30px; text-align: center; width: 600px; text-transform: uppercase;
      box-shadow: 0 0 15px var(--retro-pink); outline: none; transition: all 0.2s; z-index: 20;
    }
    .name-input:focus { box-shadow: 0 0 30px var(--retro-pink), inset 0 0 10px var(--retro-pink); border-color: #fff; }
    
    @keyframes neonPulse {
      0%, 100% { 
        color: var(--retro-highlight); 
        text-shadow: 0 0 20px var(--retro-highlight); 
        opacity: 1; 
      }
      50% { 
        color: var(--retro-pink); 
        text-shadow: 0 0 5px var(--retro-pink); 
        opacity: 0.7; 
      }
    }

    .input-attention {
      animation: neonPulse 1.2s infinite alternate;
      border-color: var(--retro-highlight) !important;
      letter-spacing: 2px;
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    .input-error {
      animation: shake 0.4s ease-in-out;
      border-color: var(--danger) !important;
      box-shadow: 0 0 20px var(--danger) !important;
    }
    
    /* HIGHSCORES */
    .highscores {
      margin-top: 30px; text-align: center; width: 500px; background: rgba(0,0,0,0.8);
      border: 2px solid #333; padding: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.8); z-index: 20;
      max-height: 350px; overflow-y: auto;
    }
    .highscores::-webkit-scrollbar { width: 8px; }
    .highscores::-webkit-scrollbar-track { background: #000; }
    .highscores::-webkit-scrollbar-thumb { background: var(--retro-pink); border-radius: 4px; }

    .hs-row {
      display: flex; justify-content: space-between; border-bottom: 1px dotted #444;
      padding: 8px 10px; font-family: 'Press Start 2P', monospace; font-size: 0.8rem; color: #aaa;
    }
    .hs-row:last-child { border-bottom: none; }
    .hs-row.header { 
        color: var(--accent); text-shadow: 0 0 5px var(--accent);
        margin-bottom: 10px; border-bottom: 2px solid var(--accent);
    }
    .hs-row span:nth-child(1) { width: 50px; text-align: left; color: var(--retro-highlight); }
    .hs-row span:nth-child(2) { flex-grow: 1; text-align: left; }
    .hs-row span:nth-child(3) { width: 100px; text-align: right; color: var(--retro-pink); }
    
    /* INFO MODAL */
    .info-content {
        width: 800px; max-height: 80vh; overflow-y: auto;
        background: rgba(0, 0, 0, 0.85); border: 2px solid var(--accent);
        padding: 30px; color: #e0e6ff; font-family: "Segoe UI", sans-serif;
        line-height: 1.6; text-align: left; position: relative; z-index: 30;
        box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
    }
    .info-content h2 { color: var(--retro-highlight); font-family: 'Orbitron', sans-serif; border-bottom: 1px solid #444; margin-top: 0; }
    .info-content h3 { color: var(--accent); margin-top: 20px; font-size: 1.1rem; text-transform: uppercase; }
    .citation {
        margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); 
        border-left: 3px solid var(--retro-pink); font-size: 0.85rem; color: #aaa;
    }
    .close-btn {
        margin-top: 20px; background: transparent; border: 2px solid var(--retro-pink); color: var(--retro-pink);
        padding: 10px 30px; cursor: pointer; font-family: 'Orbitron', sans-serif; float: right;
        transition: all 0.2s;
    }
    .close-btn:hover { background: var(--retro-pink); color: #fff; }

    .audio-select-label { font-size: 0.9rem; color: #aaa; margin-bottom: 10px; letter-spacing: 2px; position: relative; z-index: 20; }
    .audio-options { display: flex; gap: 20px; margin-bottom: 40px; z-index: 20; }
    .btn-audio {
      background: transparent; border: 1px solid #555; color: #777;
      padding: 10px 20px; cursor: pointer; font-family: 'Orbitron', sans-serif;
      font-size: 0.9rem; transition: all 0.3s;
    }
    .btn-audio.active {
      border-color: var(--retro-highlight); color: var(--retro-highlight);
      box-shadow: 0 0 15px var(--retro-highlight);
    }

    .btn-row { display: flex; gap: 20px; margin-top: 20px; z-index: 20; }
    button { font-family: 'Orbitron', sans-serif; position: relative; z-index: 20; }
    
    /* START / RETRY BUTTON */
    button.btn-start {
      background: rgba(0,0,0,0.8); color: var(--retro-highlight); font-size: 1.5rem;
      padding: 20px 50px; border: 3px solid var(--retro-highlight); 
      cursor: pointer; text-transform: uppercase; letter-spacing: 3px; transition: all 0.2s;
      box-shadow: 0 0 10px var(--retro-highlight); animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 10px var(--retro-highlight); transform: scale(1); }
      50% { box-shadow: 0 0 30px var(--retro-highlight); transform: scale(1.02); }
      100% { box-shadow: 0 0 10px var(--retro-highlight); transform: scale(1); }
    }
    button.btn-start:hover { background: var(--retro-highlight); color: #000; box-shadow: 0 0 50px var(--retro-highlight); animation: none; }
    
    /* SECONDARY BUTTON */
    button.btn-secondary {
      background: transparent; color: #fff; font-size: 1.0rem; padding: 15px 30px;
      border: 2px solid #fff; cursor: pointer; text-transform: uppercase;
      letter-spacing: 2px; transition: all 0.2s; font-weight: 700; opacity: 0.8;
    }
    button.btn-secondary:hover { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 15px var(--accent); opacity: 1; }
    
    .credits {
        margin-top: 40px; font-family: "Segoe UI", sans-serif; font-size: 0.8rem;
        color: rgba(255,255,255,0.6); text-align: center; letter-spacing: 1px; z-index: 20;
    }
    .credits strong { color: var(--accent); font-weight: 700; display: block; font-size: 0.9rem; margin-bottom: 4px; text-transform: uppercase; }
  </style>
</head>
<body>

<div class="wrap">
  <canvas id="c"></canvas>

  <div class="ui-layer">
    <div class="hud-top">
      <div class="hud-panel">SCORE: <span id="uiScore">0</span></div>
      <div class="hud-panel">SPEED: <span id="uiSpeed">0</span></div>
    
      <div class="hud-panel physics-controls">
        <div class="slider-row" style="display:none">
          <label><span>Dielectric (E<sub>r</sub>)</span> <span id="valPol">1.0</span></label>
          <input id="sliderPol" type="range" min="0" max="300" value="100">
        </div>
        
        <div class="slider-row">
           <div style="color:var(--text); font-size: 11px;">NET FORCE (Y): <span id="uiField" style="color:var(--accent)">0</span> N</div>
        </div>
      </div>
      
    </div>
    
    <div class="controls-hint">
      [SPACE] Start/Restart &nbsp;|&nbsp; [UP/DOWN] Hover &nbsp;|&nbsp; 
      <span style="color:#fff; text-shadow:0 0 5px #fff;">WHITE WALL = ATTRACTION TRAP</span>
    </div>
  </div>

  <div id="overlayStart" class="overlay">
    <h1>DIELECTRIC RUNNER</h1>
    <p class="subtitle">An Electrostatics Game</p>
    
    <button id="btnInfo" class="btn-info-corner">ABOUT</button>
    <input type="text" id="pName" class="name-input" placeholder="INSERT NAME" maxlength="8">
    
    <div class="audio-select-label">SOUND SYSTEM</div>
    <div class="audio-options">
        <button id="btnAudioRetro" class="btn-audio active">8-BIT CORE</button>
        <button id="btnAudioSpace" class="btn-audio">DEEP SPACE</button>
    </div>

    <button class="btn-start" id="btnStart">START</button>
    
    <div class="credits">
        <strong>Concept: Eric B. Lindgren</strong>
        Universidade Federal Fluminense<br>
        ericlindgren@id.uff.br<br>
        <a href="https://github.com/ericblindgren/dielectric-runner" target="_blank" style="color: inherit; text-decoration: underline; cursor: pointer;">
          https://github.com/ericblindgren/dielectric-runner
        </a> <br>
        v. 1.1 
    </div>
  </div>

  <div id="overlayGO" class="overlay hidden">
    <h1 style="font-size:5rem; margin-bottom: 0;">GAME OVER</h1>
    <p class="subtitle" style="color: var(--danger); text-shadow: 0 0 10px var(--danger);">COLLISION DETECTED</p>
    
    <div id="goScoreDisplay" style="font-family: 'Orbitron', sans-serif; font-size: 2.5rem; margin-bottom: 10px; letter-spacing: 2px;">
        FINAL SCORE: <span style="color: var(--accent); text-shadow: 0 0 10px var(--accent);">0</span>
    </div>
    
    <div class="highscores">
	  <div style="font-family: 'Press Start 2P', cursive; color: var(--retro-highlight); text-shadow: 0 0 15px var(--retro-highlight); font-size: 0.9rem; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #333; letter-spacing: 2px; text-transform: uppercase;">
		GLOBAL RANKING
	  </div>
		
      <div class="hs-row header"><span>#</span><span>PILOT</span><span>SCORE</span></div>
      <div id="hsList">
        <div class="hs-row" style="color:#777">CONNECTING TO DATABASE...</div>
      </div>
    </div>
    
    <div class="btn-row">
        <button class="btn-start" id="btnRetry">RETRY ('SPACE')</button>
        <button class="btn-secondary" id="btnNewPilot">QUIT</button>
    </div>
  </div>
  
  <div id="overlayInfo" class="overlay hidden" style="z-index: 100;">
      <div class="info-content">
          <h2>MISSION BRIEFING / ABOUT</h2>
          
          <h3>How to Play</h3>
          <ul>
              <li><strong>Controls:</strong> Use [UP] and [DOWN] arrows to hover vertically.</li>
              <li><strong>Objective:</strong> Navigate the tunnel without touching the walls. Distance traveled equals your score.</li>
              <li><strong>The Trap:</strong> Watch the wall color. <span style="color:#00f3ff; font-weight:bold;">Cyan</span> indicates a positively charged wall and <span style="color:#ff0055; font-weight:bold;">red</span> indicates a negatively charged wall. <span style="color:#ffffff; font-weight:bold;">WHITE</span> indicates an "Attraction Trap".</li> 
          </ul>

          <h3>Background Theory: Like-Charge Attraction</h3>
          <p>
              In classical electrostatics, two particles with the same charge sign repel each other according to Coulomb's Law. However, for finite-sized dielectric particles, the physics is far more complex.
          </p>
          <p>
              When charged dielectric particles approach, they induce surface charges on one another (polarization). If there is an asymmetry in the system, such as one particle being more highly charged or smaller than the other, the dominant particle exerts a strong polarizing influence. This induces a region of <em>opposite</em> charge on its neighbor.
          </p>
          <p>
              For like-charged particles, this geometry-dependent effect creates a short-range attractive force that can overcome the inherent Coulombic repulsion in some instances. In this game, getting too close to a positive wall with a high enough charge can trigger like-charge attraction, pulling your ship in right when you expect repulsion. Beware! If a <span style="color:#00f3ff; font-weight:bold;">cyan</span> wall turns <span style="color:#ffffff; font-weight:bold;">WHITE</span>, the interaction regime changes: repulsion becomes attraction.
          </p>

          <div class="citation">
              <strong>Reference:</strong><br>
              Lindgren, E. B. (2025). Charge-Induced Polarization in Dielectric Particle Systems: A Geometry-Dependent Effect. <em>Journal of Chemical Theory and Computation</em>, 21, 6135–6150.
          </div>
          
          <h3>License</h3>
			<p>
				Copyright (C) 2026 Eric B. Lindgren.
				This game is licensed under the GNU General Public License v3.0 or later.
				It comes with ABSOLUTELY NO WARRANTY.
			</p>
			<p>
				<a href="https://www.gnu.org/licenses/gpl-3.0.en.html" target="_blank" rel="license noopener noreferrer">GNU General Public License v3 (full text)</a>
			</p>
			
			<h3>Source Code</h3>
			<p>
			The complete corresponding source code for this game is available at:<br>
			<a href="https://github.com/ericblindgren/dielectric-runner"
				target="_blank"
				rel="noopener noreferrer">
				https://github.com/ericblindgren/dielectric-runner
			</a>
			</p>
			
			<h3>Third-Party Components</h3>
			<p>
				This game uses external libraries and fonts provided under their own licenses.
				These components are not covered by the GNU General Public License applied to this game.
			</p>

          <button id="btnCloseInfo" class="close-btn">CLOSE</button>
      </div>
  </div>
</div>

<script>
// ==========================================
// 1. FIREBASE SETUP
// ==========================================
const firebaseConfig = {
  apiKey: "AIzaSyCgE_ZUTphwarqUcOCjGEaohofZ5Cw5ntM",
  authDomain: "dielectric-runner.firebaseapp.com",
  projectId: "dielectric-runner",
  storageBucket: "dielectric-runner.firebasestorage.app",
  messagingSenderId: "442412282322",
  appId: "1:442412282322:web:aeab300f6b38df91ef180b",
  measurementId: "G-PJYH1ZWD7X"
};

let db = null;
try {
  firebase.initializeApp(firebaseConfig);
  db = firebase.firestore();
  console.log("Conectado ao Firebase Global!");
} catch (e) {
  console.warn("Erro ao conectar Firebase:", e);
}

function loadGlobalScores() {
  if (!db) return;
  const hsDiv = document.getElementById("hsList");
  hsDiv.innerHTML = "<div class='hs-row' style='color:#777'>LOADING GLOBAL DATA...</div>";

  // Limit to 20 for free tier safety
  db.collection("scores")
    .orderBy("score", "desc")
    .limit(20)
    .onSnapshot((snapshot) => {
      let html = "";
      let rank = 1;
      snapshot.forEach((doc) => {
        const data = doc.data();
        const safeName = escapeHtml(data.name);
        html += `
          <div class="hs-row">
            <span>#${rank}</span>
            <span>${safeName}</span>
            <span>${data.score}</span>
          </div>`;
        rank++;
      });
      hsDiv.innerHTML = html;
    }, (error) => {
      console.error("Erro leitura:", error);
      hsDiv.innerHTML = "<div class='hs-row' style='color:#f00'>DB ERROR</div>";
    });
}

function escapeHtml(text) {
  if (!text) return text;
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

// ==========================================
// 2. AUDIO ENGINE
// ==========================================
class AudioSys {
  constructor() {
    this.ctx = null;
    this.master = null;
    this.noiseBuffer = null;
    this.nextNoteTime = 0;
    this.noteIndex = 0;
    this.mode = 'retro'; 
    this.tempoRetro = 0.13;
    this.tempoSpace = 2.0; 
    this.tempoMenu = 3.0;
    this.scaleRetro = [110.00, 130.81, 146.83, 164.81, 196.00, 220.00]; 
    this.spaceNotes = [55, 65.41, 73.42, 82.41, 98, 110, 130.81]; 
    this.menuNotes = [220.00, 329.63, 392.00, 493.88, 587.33]; 
    this.droneOsc = null;
    this.droneGain = null;
    this.isPlaying = false;
  }

  setMode(m) { this.mode = m; }

  init() {
    if (this.ctx) return; 
    try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return; 
        
        this.ctx = new Ctx();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.4; 
        this.master.connect(this.ctx.destination);
        
        const bufSize = this.ctx.sampleRate * 2; 
        this.noiseBuffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const delay = this.ctx.createDelay();
        delay.delayTime.value = 0.4;
        const delayFb = this.ctx.createGain();
        delayFb.gain.value = 0.4;
        const delayFilter = this.ctx.createBiquadFilter();
        delayFilter.frequency.value = 1500; 
        
        this.master.connect(delay);
        delay.connect(delayFilter);
        delayFilter.connect(delayFb);
        delayFb.connect(delay);
        delay.connect(this.ctx.destination);
        
        this.delayNode = delay;
        this.delayFbNode = delayFb;
    } catch(e) {}
  }
  
  updateDelaySettings(active) {
      if(!this.delayNode) return;
      try {
        if (!active) {
            this.delayNode.delayTime.rampToValueAtTime(0.45, this.ctx.currentTime + 1);
            this.delayFbNode.gain.rampToValueAtTime(0.6, this.ctx.currentTime + 1);
        } else if (this.mode === 'space') {
            this.delayNode.delayTime.rampToValueAtTime(0.6, this.ctx.currentTime + 1);
            this.delayFbNode.gain.rampToValueAtTime(0.6, this.ctx.currentTime + 1);
        } else {
            this.delayNode.delayTime.rampToValueAtTime(0.25, this.ctx.currentTime + 1);
            this.delayFbNode.gain.rampToValueAtTime(0.3, this.ctx.currentTime + 1);
        }
      } catch(e) {}
  }
  
  updateDrone(active) {
      if (!this.ctx) return;
      const t = this.ctx.currentTime;
      if (!active && !this.droneOsc) {
          this.droneOsc = this.ctx.createOscillator();
          this.droneOsc.type = 'sawtooth';
          this.droneOsc.frequency.value = 55.00; 
          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 90; 
          this.droneGain = this.ctx.createGain();
          this.droneGain.gain.setValueAtTime(0, t);
          this.droneGain.gain.linearRampToValueAtTime(0.2, t + 3.0); 
          this.droneOsc.connect(filter);
          filter.connect(this.droneGain);
          this.droneGain.connect(this.master);
          this.droneOsc.start(t);
      } else if (active && this.droneOsc) {
          this.droneGain.gain.cancelScheduledValues(t);
          this.droneGain.gain.setValueAtTime(this.droneGain.gain.value, t);
          this.droneGain.gain.exponentialRampToValueAtTime(0.001, t + 1.0); 
          this.droneOsc.stop(t + 1.1);
          this.droneOsc = null;
          this.droneGain = null;
      }
  }

  resume() { try { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); } catch(e) {} }

  playBGM() {
    if (!this.ctx || !this.isPlaying) return;
    try {
        this.updateDrone(State.active);
        let currentTempo = (!State.active) ? this.tempoMenu : (this.mode === 'space' ? this.tempoSpace : this.tempoRetro);
        
        while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
          if (!State.active) this.triggerMenuNote(this.nextNoteTime);
          else if (this.mode === 'space') this.triggerSpaceNote(this.nextNoteTime);
          else this.triggerRetroNote(this.nextNoteTime);
          this.nextNoteTime += currentTempo;
        }
        if (this.ctx.currentTime % 2 < 0.1) this.updateDelaySettings(State.active);
    } catch(e) {}
  }

  triggerMenuNote(t) {
    const note = this.menuNotes[this.noteIndex % this.menuNotes.length];
    const octave = Math.random() > 0.6 ? 2 : 1; 
    const osc = this.ctx.createOscillator();
    osc.type = 'sine'; osc.frequency.value = note * octave;
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.08, t + 0.1); 
    gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0); 
    osc.connect(gain); gain.connect(this.master);
    osc.start(t); osc.stop(t + 2.5); this.noteIndex++;
  }

  triggerRetroNote(t) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const pattern = [0, 2, 3, 5, 7, 5, 3, 2, 0, 0, -3, 0, 2, 0, -3, -5];
    const idx = this.noteIndex % pattern.length;
    let noteIdx = pattern[idx];
    let freq = (noteIdx >= 0) ? this.scaleRetro[noteIdx % this.scaleRetro.length] * (1 + Math.floor(noteIdx/this.scaleRetro.length)) : this.scaleRetro[0]/2;
    osc.frequency.value = freq;
    
    if (idx % 4 === 0) {
      osc.type = 'sawtooth'; gain.gain.setValueAtTime(0.15, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
    } else {
      osc.type = 'square'; gain.gain.setValueAtTime(0.05, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    }
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass'; filter.frequency.setValueAtTime(800, t); filter.frequency.linearRampToValueAtTime(100, t + 0.2);
    osc.connect(filter); filter.connect(gain); gain.connect(this.master);
    osc.start(t); osc.stop(t + 0.4); this.noteIndex++;
  }

  triggerSpaceNote(t) {
    const freq = this.spaceNotes[Math.floor(Math.random() * this.spaceNotes.length)];
    const octave = Math.random() > 0.7 ? 2 : 1;
    const carrier = this.ctx.createOscillator(); carrier.type = 'sine'; carrier.frequency.value = freq * octave;
    const modulator = this.ctx.createOscillator(); modulator.type = 'triangle'; modulator.frequency.value = freq * 2.02; 
    const modGain = this.ctx.createGain(); modGain.gain.value = 100; 
    modulator.connect(modGain); modGain.connect(carrier.frequency);
    const masterGain = this.ctx.createGain();
    masterGain.gain.setValueAtTime(0, t); masterGain.gain.linearRampToValueAtTime(0.2, t + 0.5); masterGain.gain.exponentialRampToValueAtTime(0.001, t + 2.5); 
    carrier.connect(masterGain); masterGain.connect(this.master);
    carrier.start(t); carrier.stop(t + 3.0); modulator.start(t); modulator.stop(t + 3.0);
    this.noteIndex++;
  }

  sfxThrust() {
    if (!this.ctx) return;
    try {
        const t = this.ctx.currentTime;
        const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuffer;
        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 600; 
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.08, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15); 
        src.connect(filter); filter.connect(gain); gain.connect(this.master);
        src.start(t); src.stop(t + 0.2);
    } catch(e){}
  }

  sfxCrash() {
    if (!this.ctx) return;
    try {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        osc.connect(gain); gain.connect(this.master);
        osc.start(t); osc.stop(t+0.6);
    } catch(e){}
  }

  startMusic() { 
      try {
        if (!this.ctx) this.init(); 
        this.isPlaying = true; 
        if(this.ctx) {
            if (this.nextNoteTime < this.ctx.currentTime) this.nextNoteTime = this.ctx.currentTime + 0.1; 
            this.updateDelaySettings(State.active);
        }
      } catch(e) {}
  }
}

// ==========================================
// 3. GAME ENGINE
// ==========================================
const Audio = new AudioSys();
const btnRetro = document.getElementById('btnAudioRetro');
const btnSpace = document.getElementById('btnAudioSpace');

if (btnRetro && btnSpace) {
    btnRetro.addEventListener('click', () => { Audio.setMode('retro'); btnRetro.classList.add('active'); btnSpace.classList.remove('active'); });
    btnSpace.addEventListener('click', () => { Audio.setMode('space'); btnSpace.classList.add('active'); btnRetro.classList.remove('active'); });
}

window.addEventListener('click', () => {
   if (!Audio.ctx) { Audio.init(); Audio.resume(); Audio.startMusic(); }
}, { once: true });

const CFG = {
  W: 1200, H: 800, GRAVITY: 0, THRUST: 600, DRAG: 2.0, SCROLL_V0: 150, SCROLL_ACCEL: 8,
  SEG_LEN: 300, WALL_GAP: 500, K_COULOMB: 80, K_LIKE_BASE: 15.0, DIELECTRIC_MULT: 1.0, 
  DIST_SCALE: 100, ISO_ANGLE: 0.6, FOV: 600
};

const State = {
  active: false, paused: false, over: false, time: 0, score: 0, distance: 0, speed: CFG.SCROLL_V0,
  player: { y: 0, vy: 0, q: 1 }, trail: [], segments: [], particles: [], forces: { topC:0, topP:0, botC:0, botP:0 }
};

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let bounds = { w: 0, h: 0 };
function resize() {
  bounds.w = window.innerWidth; bounds.h = window.innerHeight;
  canvas.width = bounds.w; canvas.height = bounds.h;
}
window.addEventListener('resize', resize);
resize();

const Input = { up: false, down: false };
window.addEventListener('keydown', e => {
  if(e.code === 'Space') handleSpace();
  if(e.code === 'ArrowUp' || e.code === 'KeyW') Input.up = true;
  if(e.code === 'ArrowDown' || e.code === 'KeyS') Input.down = true;
});
window.addEventListener('keyup', e => {
  if(e.code === 'ArrowUp' || e.code === 'KeyW') Input.up = false;
  if(e.code === 'ArrowDown' || e.code === 'KeyS') Input.down = false;
});

const uiScore = document.getElementById('uiScore');
const uiSpeed = document.getElementById('uiSpeed');
const uiField = document.getElementById('uiField');
const sliderPol = document.getElementById('sliderPol');
const valPol = document.getElementById('valPol');
const overlayStart = document.getElementById('overlayStart');
const overlayGO = document.getElementById('overlayGO');
const overlayInfo = document.getElementById('overlayInfo');
const btnStart = document.getElementById('btnStart');
const btnRetry = document.getElementById('btnRetry');
const btnNewPilot = document.getElementById('btnNewPilot');
const btnInfo = document.getElementById('btnInfo');
const btnCloseInfo = document.getElementById('btnCloseInfo');
const pNameInput = document.getElementById('pName');

// NAME FILTER: No Spaces, Lowercase
pNameInput.addEventListener('input', function(e) {
  let val = e.target.value;
  val = val.toLowerCase();
  val = val.replace(/\s/g, ''); 
  e.target.value = val;
});

sliderPol.addEventListener('input', (e) => {
  const val = parseFloat(e.target.value) / 100;
  CFG.DIELECTRIC_MULT = val; valPol.innerText = val.toFixed(2);
});

btnInfo.addEventListener('click', () => {
    overlayInfo.classList.remove('hidden');
    if (State.active) { State.active = false; State.paused = true; }
});
btnCloseInfo.addEventListener('click', () => {
    overlayInfo.classList.add('hidden');
    if (State.paused) { State.active = true; State.paused = false; }
});

const defaultText = "INSERT NAME";
const savedName = localStorage.getItem("ion_runner_name");

// 1. Initialize Input
if (savedName && savedName !== "guest") {
    // If we have a real player name saved, show it normally
    pNameInput.value = savedName;
} else {
    // Otherwise, show the blinking prompt
    pNameInput.value = defaultText;
    pNameInput.classList.add('input-attention');
}

// 2. Clear on Click (Focus)
pNameInput.addEventListener('focus', () => {
    if (pNameInput.value === defaultText) {
        pNameInput.value = "";
        pNameInput.classList.remove('input-attention');
    }
});

// 3. Restore if Left Empty (Blur)
pNameInput.addEventListener('blur', () => {
    if (pNameInput.value.trim() === "") {
        pNameInput.value = defaultText;
        pNameInput.classList.add('input-attention');
    }
});

function handleSpace() {
  if (!overlayInfo.classList.contains('hidden')) return;
  // SPACE ONLY RESTARTS GAME
  if (State.over) resetGame();
}

btnStart.addEventListener('click', startGame);
btnRetry.addEventListener('click', resetGame);
btnNewPilot.addEventListener('click', goToMenu);

function startGame() {
  const val = pNameInput.value;
  
  if (!val || val.trim() === "" || val === defaultText) {
    // Trigger Shake Effect
    pNameInput.classList.add('input-error');
    // Remove class after 400ms so it can be triggered again
    setTimeout(() => pNameInput.classList.remove('input-error'), 400);
    pNameInput.focus();
    return; // STOP THE GAME FROM STARTING
  }

  if (pNameInput) localStorage.setItem("ion_runner_name", pNameInput.value);
  try { if(!Audio.ctx) Audio.init(); Audio.resume(); Audio.startMusic(); } catch (e) {}
  overlayStart.classList.add('hidden');
  resetPhysics();
  State.active = true; State.over = false; State.paused = false;
}

function resetGame() {
  overlayGO.classList.add('hidden');
  resetPhysics();
  State.active = true; State.over = false;
  try { Audio.startMusic(); } catch(e){}
}

function goToMenu() {
    overlayGO.classList.add('hidden'); 
    overlayStart.classList.remove('hidden');
    pNameInput.value = ""; 
    pNameInput.focus();
    
    State.active = false; 
    State.paused = false;
    State.over = false;
}

function resetPhysics() {
  State.time = 0; State.score = 0; State.distance = 0; State.speed = CFG.SCROLL_V0;
  State.player.y = 0; State.player.vy = 0;
  State.segments = []; State.particles = []; State.trail = [];
  State.forces = { topC:0, topP:0, botC:0, botP:0 };
  for(let i=0; i<10; i++) addSegment(i * CFG.SEG_LEN);
}

function addSegment(x) {
  const isSafe = x < 600; 
  const progression = Math.floor(State.distance / 3000);
  const qMax = Math.min(30, 10 + progression * 2);
  const getMag = () => Math.floor(Math.random() * (qMax - 1)) + 1; 
  let qTop = isSafe ? 0 : (Math.random() > 0.5 ? 1 : -1) * getMag();
  let qBot = isSafe ? 0 : (Math.random() > 0.5 ? 1 : -1) * getMag();
  if(Math.random() < 0.25 && !isSafe) qTop = Math.abs(qTop) * 1.5; 
  State.segments.push({ x: x, w: CFG.SEG_LEN, qTop, qBot });
}

function update(dt) {
  State.time += dt; State.speed += CFG.SCROLL_ACCEL * dt; State.distance += State.speed * dt;
  State.score = Math.floor(State.distance / 10);
  
  const lastSeg = State.segments[State.segments.length-1];
  if (lastSeg.x < State.distance + bounds.w + 500) addSegment(lastSeg.x + CFG.SEG_LEN);
  if (State.segments[0].x + CFG.SEG_LEN < State.distance - 1000) State.segments.shift();
  
  const p = State.player;
  const currSeg = State.segments.find(s => s.x <= State.distance + 200 && s.x + CFG.SEG_LEN > State.distance + 200) || State.segments[0];
  
  let thrust = 0;
  if (Input.up) thrust -= CFG.THRUST;
  if (Input.down) thrust += CFG.THRUST;
  
  const distScale = CFG.DIST_SCALE;
  const dTop = (p.y - (-CFG.WALL_GAP/2));
  const dBot = ((CFG.WALL_GAP/2) - p.y);
  const dtS = Math.max(5, dTop) / distScale;
  const dbS = Math.max(5, dBot) / distScale;
  
  const K_LIKE = CFG.K_LIKE_BASE * CFG.DIELECTRIC_MULT;
  
  const F_Top_C = (CFG.K_COULOMB * currSeg.qTop) / (dtS*dtS);
  const F_Top_P = (K_LIKE * currSeg.qTop*currSeg.qTop) / (dtS*dtS*dtS);
  const F_Top = F_Top_C - F_Top_P; 

  const F_Bot_C = (CFG.K_COULOMB * currSeg.qBot) / (dbS*dbS); 
  const F_Bot_P = (K_LIKE * currSeg.qBot*currSeg.qBot) / (dbS*dbS*dbS);
  const F_Bot_Net = -( (CFG.K_COULOMB * currSeg.qBot) / (dbS*dbS) ) + F_Bot_P;
  
  const totalAy = CFG.GRAVITY + thrust + F_Top + F_Bot_Net;
  
  State.forces.topC = Math.abs(F_Top_C); State.forces.topP = Math.abs(F_Top_P);
  State.forces.botC = Math.abs(F_Bot_C); State.forces.botP = Math.abs(F_Bot_P);
  
  p.vy += totalAy * dt;
  p.vy *= Math.exp(-CFG.DRAG * dt);
  p.y += p.vy * dt;

  State.trail.push({ x: State.distance + 200, y: p.y });
  if (State.trail.length > 100) State.trail.shift();

  if (Input.up || Input.down) {
    if (Math.random() < 0.6) {
      const exhaustDir = Input.up ? 1 : -1; 
      State.particles.push({
        x: State.distance + 200, y: p.y, vx: -State.speed - Math.random()*50, 
        vy: exhaustDir * (100 + Math.random()*100), life: 0.8, color: Input.up ? '#0ff' : '#f0f' 
      });
      Audio.sfxThrust();
    }
  }
  
  for (let i=State.particles.length-1; i>=0; i--) {
    let pt = State.particles[i]; pt.x += pt.vx * dt; pt.y += pt.vy * dt; pt.life -= dt * 2.5; 
    if (pt.life <= 0) State.particles.splice(i, 1);
  }
  
  if (p.y < -CFG.WALL_GAP/2 + 20 || p.y > CFG.WALL_GAP/2 - 20) gameOver();

  uiScore.innerText = State.score; uiSpeed.innerText = Math.floor(State.speed);
  const netF = (F_Top + F_Bot_Net);
  uiField.innerText = netF.toFixed(0); uiField.style.color = Math.abs(netF) > 1000 ? '#ff0055' : '#00f3ff';
}

function gameOver() {
  State.active = false; State.over = true;
  Audio.sfxCrash();
  
  const finalScore = State.score;
  const pilotName = pNameInput.value.trim() || "pilot";
  
  document.getElementById('goScoreDisplay').innerHTML = `FINAL SCORE: <span style="color: var(--accent); text-shadow: 0 0 10px var(--accent);">${finalScore}</span>`;

  overlayGO.classList.remove('hidden');
  loadGlobalScores();

  if (db && finalScore > 0) {
    db.collection("scores").add({
      name: pilotName,
      score: finalScore,
      date: firebase.firestore.FieldValue.serverTimestamp()
    })
    .then(() => { console.log("Pontuação salva!"); })
    .catch((error) => { 
        // Log técnico no console para debug
        console.error("Database Write Error:", error); 
        
        alert("Error: Score submission failed.");
        
        // Volta ao menu para tentar novamente
        goToMenu();
    });
  }
}

// ==========================================
// 4. RENDERER
// ==========================================
function render() {
  ctx.fillStyle = "#050510";
  ctx.fillRect(0, 0, bounds.w, bounds.h);
  
  const cx = bounds.w / 2;
  const cy = bounds.h / 2;
  
  // Grid
  ctx.save();
  ctx.strokeStyle = "rgba(0, 243, 255, 0.1)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  const gridOff = -(State.distance % 100);
  for(let i=0; i<bounds.w/100 + 2; i++){
    let gx = i*100 + gridOff;
    ctx.moveTo(gx, 0); ctx.lineTo(gx, bounds.h);
  }
  for(let i=0; i<bounds.h/100; i++){
    ctx.moveTo(0, i*100); ctx.lineTo(bounds.w, i*100);
  }
  ctx.stroke();
  ctx.restore();

  // Identify current segment
  const currentSegment = State.segments.find(s => s.x <= State.distance + 200 && s.x + CFG.SEG_LEN > State.distance + 200) || State.segments[0];

  // Walls
  const wallDepth = 60; 
  const viewTilt = 0.4; 
  
  if (State.segments.length > 0) {
      State.segments.forEach(s => {
        const x1 = (s.x - State.distance) + 200; 
        const x2 = (s.x + CFG.SEG_LEN - State.distance) + 200;
        
        if (x2 < -300 || x1 > bounds.w + 100) return;
        
        const yTop = cy - CFG.WALL_GAP/2;
        const yBot = cy + CFG.WALL_GAP/2;
        const hWall = 200;
        
        const isActiveSegment = (s === currentSegment);

        const getC = (q) => {
          if (q === 0) return [60, 60, 70];
          if (q > 0) return [0, 243, 255]; 
          return [255, 0, 85];             
        };
        
        const drawBlock = (yBase, h, q, isCeiling) => {
          let c = getC(q);
          let intensity = Math.min(1, Math.abs(q)/10); 
          let alpha = (q === 0) ? 0.8 : (0.3 + 0.7*intensity);
          
          let isLCA = false;
          if (isActiveSegment && q > 0) {
              if (isCeiling) { if (State.forces.topP > State.forces.topC) isLCA = true; } 
              else { if (State.forces.botP > State.forces.botC) isLCA = true; }
          }

          let colStr;
          if (isLCA) { colStr = "rgba(255, 255, 255, 1.0)"; alpha = 1.0; } 
          else { colStr = `rgba(${c[0]},${c[1]},${c[2]},${alpha})`; }

          const offX = wallDepth; 
          const offY = isCeiling ? wallDepth * viewTilt : -wallDepth * viewTilt;
          const yEdge = yBase;
          const yFar = isCeiling ? yBase - h : yBase + h;
          
          // Draw 3D side
          ctx.beginPath();
          ctx.moveTo(x1, yEdge);
          ctx.lineTo(x2, yEdge);
          ctx.lineTo(x2 + offX, yEdge + offY);
          ctx.lineTo(x1 + offX, yEdge + offY);
          ctx.closePath();
          if (isLCA) ctx.fillStyle = "#ccc"; 
          else ctx.fillStyle = `rgba(${c[0]*0.5},${c[1]*0.5},${c[2]*0.5},${alpha})`; 
          ctx.fill();
          ctx.strokeStyle = colStr; ctx.lineWidth = 1; ctx.stroke();

          // Draw Front Face
          ctx.beginPath();
          ctx.moveTo(x1, yEdge);
          ctx.lineTo(x2, yEdge);
          ctx.lineTo(x2, yFar);
          ctx.lineTo(x1, yFar);
          ctx.closePath();
          
          if (Math.abs(q) > 0) {
            ctx.shadowBlur = isLCA ? 40 : (20 + Math.abs(q)*2);
            ctx.shadowColor = colStr;
          }
          
          if (isLCA) ctx.fillStyle = "#fff";
          else ctx.fillStyle = `rgba(${c[0]*0.2},${c[1]*0.2},${c[2]*0.2}, 0.9)`; 
          
          ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
          
          if (Math.abs(q) > 0) {
            ctx.fillStyle = isLCA ? "#000" : "#fff";
            ctx.font = "bold 20px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(q > 0 ? "+" + q.toFixed(0) : q.toFixed(0), (x1+x2)/2, (yEdge + yFar)/2);
          }
        };
        drawBlock(yTop, hWall, s.qTop, true);
        drawBlock(yBot, hWall, s.qBot, false);
      });
  }

  // Trail
  if (State.trail.length > 1) {
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.shadowBlur = 10;
    ctx.shadowColor = "#00f3ff";
    ctx.strokeStyle = "rgba(0, 243, 255, 0.2)"; 
    ctx.lineWidth = 6;
    for (let i = 0; i < State.trail.length; i++) {
      const p = State.trail[i];
      const sx = (p.x - State.distance);
      const sy = cy + p.y;
      if(i===0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    ctx.lineWidth = 3;
    for (let i = 1; i < State.trail.length; i++) {
      const p1 = State.trail[i-1];
      const p2 = State.trail[i];
      const sx1 = (p1.x - State.distance);
      const sy1 = cy + p1.y;
      const sx2 = (p2.x - State.distance);
      const sy2 = cy + p2.y;
      const alpha = (i / State.trail.length);
      ctx.beginPath();
      ctx.moveTo(sx1, sy1);
      ctx.lineTo(sx2, sy2);
      ctx.strokeStyle = `rgba(0, 243, 255, ${alpha})`; 
      ctx.stroke();
    }
    ctx.restore();
  }

  // Particles
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for(let p of State.particles) {
    const ppx = (p.x - State.distance); 
    const ppy = cy + p.y;
    if (ppx < -50 || ppx > bounds.w + 50) continue;

    ctx.beginPath();
    ctx.arc(ppx, ppy, 3*p.life, 0, Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life;
    ctx.fill();
  }
  ctx.restore();
  
  // PLAYER RENDER
  const px = 200; 
  const py = cy + State.player.y;
  
  ctx.save();
  
  ctx.shadowBlur = 20;
  ctx.shadowColor = "#fff";
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(px, py, 10, 0, Math.PI*2);
  ctx.fill();
  
  ctx.shadowBlur = 40;
  ctx.shadowColor = "#00f3ff";
  ctx.strokeStyle = "#00f3ff";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(px, py, 16 + Math.sin(Date.now()/100)*2, 0, Math.PI*2);
  ctx.stroke();
  
  ctx.shadowBlur = 0;
  ctx.fillStyle = "#000";
  ctx.font = "bold 12px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("+1", px, py);
  
  ctx.restore();
}

function loop() {
  const now = performance.now();
  const dt = Math.min(0.05, (now - (State.lastTime || now)) / 1000);
  State.lastTime = now;
  
  if (State.active) update(dt);
  
  Audio.playBGM();
  render();
  requestAnimationFrame(loop);
}

// Initial physics setup (so menu isn't empty)
resetPhysics();
loop();
</script>
</body>
</html>
