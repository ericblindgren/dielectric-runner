<!doctype html>
<html lang="en">
<!--
Dielectric Runner - An Electrostatics Game
Copyright (C) 2026 Eric B. Lindgren

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the LICENSE file (GPLv3) for details.
-->
<!-- SPDX-License-Identifier: GPL-3.0-or-later -->
<head>
  <script type="text/javascript">
        if (screen.width > 800 && !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            window.location.replace("index.html"); 
        }
    </script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Dielectric Runner</title>
  
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Crect width='16' height='16' fill='%23050510'/%3E%3Cpath d='M2 8c2-4 4-4 6 0s4 4 6 0' fill='none' stroke='%2300f3ff' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Press+Start+2P&display=swap" rel="stylesheet">

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics-compat.js"></script>

  <style>
    /* --- AESTHETICS --- */
    :root {
      --bg: #050510;
      --ui-bg: rgba(10, 10, 20, 0.85);
      --accent: #00f3ff;
      --danger: #ff0055;
      --text: #e0e6ff;
      --lca-white: #ffffff;
      --retro-pink: #ff00de;
      --retro-purple: #9d00ff;
      --retro-highlight: #ff3300; 
      --retro-grid: rgba(255, 0, 222, 0.15);
    }
    
    @keyframes flicker {
      0%, 18%, 22%, 25%, 53%, 57%, 100% { opacity: 1; transform: skew(-5deg) scale(1); }
      20%, 24%, 55% { opacity: 0.5; transform: skew(-5deg) scale(0.98); }
    }
    
    html, body {
      height: 100%; margin: 0; padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden; /* Prevent scrolling */
      touch-action: none; /* Disable default touch actions */
      -webkit-user-select: none; /* Disable selection */
      user-select: none;
    }
    body { display: grid; place-items: center; }
    
    .wrap {
      position: relative;
      width: 100%; height: 100%;
      background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
    }
    canvas { display: block; width: 100%; height: 100%; }
    
    /* HUD & UI - MOBILE OPTIMIZED */
    .ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 15px; box-sizing: border-box; z-index: 5;
    }
    
    /* Top Bar: Score and Speed split */
    .hud-top {
      display: flex; justify-content: space-between; align-items: flex-start;
      width: 100%;
      font-family: 'Orbitron', sans-serif;
    }
    
    .hud-stat {
      display: flex; flex-direction: column; align-items: flex-start;
    }
    .hud-stat.right { align-items: flex-end; }
    
    .hud-label {
      font-size: 10px; color: #aaa; letter-spacing: 1px; margin-bottom: 2px;
    }
    .hud-value {
      font-size: 24px; font-weight: 900; color: #fff;
      text-shadow: 0 0 10px var(--accent);
    }

    /* Force Indicator centered bottom */
    .hud-force {
      position: absolute; bottom: 120px; left: 0; right: 0;
      text-align: center; font-size: 12px; font-family: 'Orbitron', sans-serif;
      color: var(--text); opacity: 0.8; pointer-events: none;
    }

    /* MOBILE CONTROLS OVERLAY */
    .mobile-controls {
      position: absolute; bottom: 20px; left: 0; width: 100%;
      display: flex; justify-content: space-between; padding: 0 20px;
      box-sizing: border-box; pointer-events: none; /* Let clicks pass through gaps */
      z-index: 50;
    }
    
    .control-btn {
      pointer-events: auto;
      width: 80px; height: 80px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(0, 243, 255, 0.3);
      display: grid; place-items: center;
      color: var(--accent); font-size: 24px; font-family: 'Orbitron', sans-serif;
      backdrop-filter: blur(2px);
      transition: all 0.1s;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    .control-btn:active, .control-btn.pressed {
      background: rgba(0, 243, 255, 0.2);
      border-color: var(--accent);
      transform: scale(0.95);
      box-shadow: 0 0 15px var(--accent);
    }
    
    /* Button Placement */
    .btn-up { position: absolute; bottom: 20px; left: 20px; }
    .btn-down { position: absolute; bottom: 20px; right: 20px; }

    /* Info Button (moved below credits on mobile) */
    .btn-info-corner {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid var(--accent);
        color: var(--accent);
        padding: 10px 20px;
        font-family: 'Orbitron', sans-serif;
        font-size: 0.8rem;
        cursor: pointer;
        text-transform: uppercase;
        z-index: 50;
        position: static;
        margin-top: 12px;
        align-self: center;
    }
    a.btn-info-corner { 
      display: inline-block; 
      text-decoration: none; 
      text-align: center; 
    }

    /* OVERLAYS */
    .overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: 
        linear-gradient(rgba(10, 0, 30, 0.95), rgba(5, 0, 15, 0.98)),
        linear-gradient(0deg, var(--retro-grid) 1px, transparent 1px),
        linear-gradient(90deg, var(--retro-grid) 1px, transparent 1px);
      background-size: 100% 100%, 30px 30px, 30px 30px;
      backdrop-filter: blur(8px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      pointer-events: auto; transition: opacity 0.3s ease; z-index: 100;
      padding: 20px; box-sizing: border-box;
      font-family: 'Orbitron', sans-serif;
    }
    .hidden { opacity: 0; pointer-events: none; }
    
    .overlay h1 {
      font-family: 'Press Start 2P', cursive; font-size: 2.2rem; margin: 0 0 20px 0;
      text-transform: uppercase; line-height: 1.4; text-align: center;
      background: linear-gradient(to bottom, #fff 0%, var(--retro-highlight) 50%, var(--retro-pink) 51%, var(--retro-purple) 100%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      filter: drop-shadow(2px 2px 0px #000) drop-shadow(0 0 10px var(--retro-pink));
      transform: skew(-5deg); animation: flicker 3s infinite;
    }
    
    .overlay-scroll-container {
      width: 100%;
      display: flex; flex-direction: column; align-items: center;
      overflow-y: auto;
      max-height: 100vh;
      padding-bottom: 50px;
    }

    p.subtitle {
      font-family: 'Orbitron', sans-serif; font-size: 1.0rem; color: var(--accent);
      margin-bottom: 20px; letter-spacing: 2px; text-transform: uppercase;
      text-shadow: 0 0 10px var(--accent); border-top: 1px solid var(--accent);
      border-bottom: 1px solid var(--accent); padding: 5px 10px; background: rgba(0, 243, 255, 0.1);
    }
    
    .name-input {
      background: #000; border: 2px solid var(--retro-pink); color: var(--retro-highlight);
      padding: 15px; font-family: 'Press Start 2P', cursive; font-size: 1.2rem;
      margin-bottom: 20px; text-align: center; width: 85%; text-transform: uppercase;
      box-shadow: 0 0 10px var(--retro-pink); outline: none; transition: all 0.2s;
      border-radius: 4px;
    }
    .name-input:focus { box-shadow: 0 0 20px var(--retro-pink); border-color: #fff; }
    
    @keyframes neonPulse {
      0%, 100% { color: var(--retro-highlight); text-shadow: 0 0 20px var(--retro-highlight); opacity: 1; }
      50% { color: var(--retro-pink); text-shadow: 0 0 5px var(--retro-pink); opacity: 0.7; }
    }
    .input-attention { animation: neonPulse 1.2s infinite alternate; border-color: var(--retro-highlight) !important; }
    
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-10px); } 75% { transform: translateX(10px); } }
    .input-error { animation: shake 0.4s ease-in-out; border-color: var(--danger) !important; box-shadow: 0 0 20px var(--danger) !important; }
    
    /* HIGHSCORES MOBILE */
    .highscores {
      margin-top: 20px; text-align: center; width: 95%; background: rgba(0,0,0,0.8);
      border: 1px solid #333; padding: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.8);
      max-height: 250px; overflow-y: auto; font-size: 0.7rem;
    }
    
    /* INFO MODAL MOBILE */
    .info-content {
        width: 95%; max-height: 85vh; overflow-y: auto;
        background: rgba(0, 0, 0, 0.95); border: 1px solid var(--accent);
        padding: 20px; color: #e0e6ff; font-family: "Segoe UI", sans-serif;
        line-height: 1.5; text-align: left; position: relative;
        box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
        font-size: 0.9rem;
    }
    .info-content h2 { font-size: 1.2rem; }
    .info-content h3 { font-size: 1.0rem; margin-top: 15px; }
    .close-btn { width: 100%; padding: 15px; margin-top: 15px; font-size: 1rem; }

    .audio-options { display: flex; gap: 10px; margin-bottom: 30px; }
    .btn-audio {
      padding: 10px 15px; font-size: 0.7rem; flex: 1;
    }

    .btn-row { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; width: 100%; align-items: center; }
    
    button.btn-start {
      background: rgba(0,0,0,0.8); color: var(--retro-highlight); font-size: 1.2rem;
      padding: 20px 0; width: 85%; border: 3px solid var(--retro-highlight); 
      cursor: pointer; text-transform: uppercase; letter-spacing: 3px;
      box-shadow: 0 0 10px var(--retro-highlight); animation: pulse 1.5s infinite;
      border-radius: 8px;
    }
    
    button.btn-secondary {
      background: transparent; color: #fff; font-size: 0.9rem; padding: 15px 0; width: 85%;
      border: 2px solid #fff; cursor: pointer; text-transform: uppercase;
      letter-spacing: 2px; opacity: 0.8; border-radius: 8px;
    }
    
    .credits {
        margin-top: 30px;
        font-family: "Segoe UI", sans-serif;
        font-size: 0.8rem;
        color: rgba(255,255,255,0.6);
        text-align: center;
        letter-spacing: 1px;
        width: 90%;
        z-index: 20;
    }
    .credits strong {
        color: var(--accent);
        font-weight: 700;
        display: block;
        font-size: 0.9rem;
        margin-bottom: 4px;
        text-transform: uppercase;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 10px var(--retro-highlight); transform: scale(1); }
      50% { box-shadow: 0 0 40px var(--retro-highlight); transform: scale(1.03); }
    }

    button { font-family: 'Orbitron', sans-serif; position: relative; z-index: 20; }

    .audio-select-label {
      font-size: 0.9rem;
      color: #aaa;
      margin-bottom: 10px;
      letter-spacing: 2px;
      position: relative;
      z-index: 20;
      text-transform: uppercase;
    }

    .btn-audio {
      background: transparent;
      border: 1px solid #555;
      color: #777;
      padding: 10px 15px;            /* mobile-friendly */
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
      font-size: 0.8rem;
      transition: all 0.3s;
      flex: 1;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 0;
    }
    .btn-audio.active {
      border-color: var(--retro-highlight);
      color: var(--retro-highlight);
      box-shadow: 0 0 15px var(--retro-highlight);
    }

    button.btn-start {
      transition: all 0.2s;
      border-radius: 0;
    }
    button.btn-start:hover {
      background: var(--retro-highlight);
      color: #000;
      box-shadow: 0 0 50px var(--retro-highlight);
      animation: none;
    }

    button.btn-secondary {
      transition: all 0.2s;
      font-weight: 700;
      border-radius: 0;
    }
    button.btn-secondary:hover {
      opacity: 1.0;
      box-shadow: 0 0 20px rgba(255,255,255,0.25);
      transform: translateY(-1px);
    }

    .name-input { border-radius: 0; }

    .btn-info-corner {
      position: static;
      margin-top: 12px;
      padding: 10px 20px;
      font-size: 0.8rem;
      transition: all 0.2s;
    }
    .btn-info-corner:hover {
      background: rgba(0, 243, 255, 0.15);
      box-shadow: 0 0 20px rgba(0, 243, 255, 0.35);
      transform: translateY(-1px);
    }

    .citation {
      margin-top: 20px;
      padding: 15px;
      background: rgba(255,255,255,0.05);
      border-left: 3px solid var(--retro-pink);
      font-size: 0.85rem;
      color: #aaa;
    }

    .info-content {
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid var(--accent);
      line-height: 1.6;
    }

  </style>
</head>
<body>

<div class="wrap">
  <canvas id="c"></canvas>

  <div class="ui-layer">
    <div class="hud-top">
        <div class="hud-stat">
            <span class="hud-label">SCORE</span>
            <span id="uiScore" class="hud-value">0</span>
        </div>
        <div class="hud-stat right">
            <span class="hud-label">SPEED</span>
            <span id="uiSpeed" class="hud-value">0</span>
        </div>
    </div>
    
    <div class="hud-force">
        NET FORCE (Y): <span id="uiField" style="color:var(--accent)">0</span> N
    </div>

    <div class="mobile-controls" id="mobControls">
        <div class="control-btn btn-up" id="btnUpPad">▲</div>
        <div class="control-btn btn-down" id="btnDownPad">▼</div>
    </div>
  </div>

  
  <div id="overlayStart" class="overlay">
    <div class="overlay-scroll-container">
        <h1>DIELECTRIC RUNNER</h1>
        <p class="subtitle">Mobile Edition</p>

        <input type="text" id="pName" class="name-input" placeholder="INSERT NAME" maxlength="8">

        <div class="audio-select-label">SOUND SYSTEM</div>
        <div class="audio-options">
            <button id="btnAudioRetro" class="btn-audio active">8-BIT CORE</button>
            <button id="btnAudioSpace" class="btn-audio">DEEP SPACE</button>
        </div>

        <button class="btn-start" id="btnStart">START</button>

        <div class="credits">
        <strong>Concept: Eric B. Lindgren</strong>
        Universidade Federal Fluminense<br>
        ericlindgren@id.uff.br<br>
        <a href="https://github.com/ericblindgren/dielectric-runner" target="_blank" style="color: inherit; text-decoration: underline; cursor: pointer;">
          https://github.com/ericblindgren/dielectric-runner
        </a> <br>
        v. 1.0m <br> <br>
        <strong>Collaborator: Gustavo Souza</strong>
        gsdacosta.24@gmail.com<br> <br>
    </div>
        <button id="btnInfo" class="btn-info-corner">ABOUT</button>
        <!--
        <a id="btnDesktop" class="btn-info-corner"
			href="index.html">DESKTOP VERSION</a>,
			-->
    </div>
  </div>

  <div id="overlayGO" class="overlay hidden">
    <div class="overlay-scroll-container">
        <h1 style="font-size:3rem; margin-bottom: 0;">GAME OVER</h1>
        <p class="subtitle" style="color: var(--danger); text-shadow: 0 0 10px var(--danger);">COLLISION DETECTED</p>
        
        <div id="goScoreDisplay" style="font-family: 'Orbitron', sans-serif; font-size: 2.0rem; margin-bottom: 10px; letter-spacing: 2px;">
            SCORE: <span style="color: var(--accent);">0</span>
        </div>
        
        <div class="highscores">
          <div style="font-family: 'Press Start 2P', cursive; color: var(--retro-highlight); font-size: 0.7rem; margin-bottom: 10px; border-bottom: 1px solid #333;">
            GLOBAL RANKING
          </div>
          <div class="hs-row header" style="display:flex; justify-content:space-between; color:var(--accent); font-size:0.7rem; border-bottom:1px solid var(--accent); margin-bottom:5px;">
			<span style="width:30px; text-align:left;">#</span>
			<span style="flex-grow:1; text-align:left;">PILOT</span>
			<span style="text-align:right;">SCORE</span>
		  </div>
          <div id="hsList">
            <div style="color:#777">LOADING...</div>
          </div>
        </div>
        
        <div class="btn-row">
            <button class="btn-start" id="btnRetry">RETRY</button>
            <button class="btn-secondary" id="btnNewPilot">QUIT</button>
        </div>
    </div>
  </div>
  
  <div id="overlayInfo" class="overlay hidden" style="z-index: 150;">
      <div class="info-content">
          <h2>MISSION BRIEFING / ABOUT</h2>
          
          <h3>How to Play</h3>
          <ul>
              <li><strong>Controls:</strong> Use ▲ / ▼ to hover vertically (or [UP] / [DOWN] keys).</li>
              <li><strong>Objective:</strong> Navigate the tunnel without touching the walls. Distance traveled equals your score.</li>
              <li><strong>The Trap:</strong> Watch the wall color. <span style="color:#00f3ff; font-weight:bold;">Cyan</span> indicates a positively charged wall and <span style="color:#ff0055; font-weight:bold;">red</span> indicates a negatively charged wall. <span style="color:#ffffff; font-weight:bold;">WHITE</span> indicates an "Attraction Trap".</li> 
          </ul>

          <h3>Background Theory: Like-Charge Attraction</h3>
          <p>
              In classical electrostatics, two particles with the same charge sign repel each other according to Coulomb's Law. However, for finite-sized dielectric particles, the physics is far more complex.
          </p>
          <p>
              When charged dielectric particles approach, they induce surface charges on one another (polarization). If there is an asymmetry in the system, such as one particle being more highly charged or smaller than the other, the dominant particle exerts a strong polarizing influence. This induces a region of <em>opposite</em> charge on its neighbor.
          </p>
          <p>
              For like-charged particles, this geometry-dependent effect creates a short-range attractive force that can overcome the inherent Coulombic repulsion in some instances. In this game, getting too close to a positive wall with a high enough charge can trigger like-charge attraction, pulling your ship in right when you expect repulsion. Beware! If a <span style="color:#00f3ff; font-weight:bold;">cyan</span> wall turns <span style="color:#ffffff; font-weight:bold;">WHITE</span>, the interaction regime changes: repulsion becomes attraction.
          </p>

          <div class="citation">
              <strong>Reference:</strong><br>
              Lindgren, E. B. (2025). Charge-Induced Polarization in Dielectric Particle Systems: A Geometry-Dependent Effect. <em>Journal of Chemical Theory and Computation</em>, 21, 6135–6150.
          </div>
          
          <h3>License</h3>
			<p>
				Copyright (C) 2026 Eric B. Lindgren.
				This game is licensed under the GNU General Public License v3.0 or later.
				It comes with ABSOLUTELY NO WARRANTY.
			</p>
			<p>
				<a href="https://www.gnu.org/licenses/gpl-3.0.en.html" target="_blank" rel="license noopener noreferrer">GNU General Public License v3 (full text)</a>
			</p>
			
			<h3>Source Code</h3>
			<p>
			The complete corresponding source code for this game is available at:<br>
			<a href="https://github.com/ericblindgren/dielectric-runner"
				target="_blank"
				rel="noopener noreferrer">
				https://github.com/ericblindgren/dielectric-runner
			</a>
			</p>
			
			<h3>Third-Party Components</h3>
			<p>
				This game uses external libraries and fonts provided under their own licenses.
				These components are not covered by the GNU General Public License applied to this game.
			</p>

          <button id="btnCloseInfo" class="close-btn">CLOSE</button>
      </div>
  </div>
</div>

<script>
// ==========================================
// 1. FIREBASE SETUP
// ==========================================
const firebaseConfig = {
  apiKey: "AIzaSyCgE_ZUTphwarqUcOCjGEaohofZ5Cw5ntM",
  authDomain: "dielectric-runner.firebaseapp.com",
  projectId: "dielectric-runner",
  storageBucket: "dielectric-runner.firebasestorage.app",
  messagingSenderId: "442412282322",
  appId: "1:442412282322:web:aeab300f6b38df91ef180b",
  measurementId: "G-PJYH1ZWD7X"
};

let db = null;
try {
  firebase.initializeApp(firebaseConfig);
  analytics = firebase.analytics();
  db = firebase.firestore();
  console.log("Conectado ao Firebase Mobile!");
} catch (e) {
  console.warn("Erro ao conectar Firebase:", e);
}

function loadGlobalScores() {
  if (!db) return;
  const hsDiv = document.getElementById("hsList");
  hsDiv.innerHTML = "<div style='color:#777'>LOADING...</div>";

  db.collection("scores")
    .orderBy("score", "desc")
    .limit(20) // Reduced limit for mobile view
    .onSnapshot((snapshot) => {
      let html = "";
      let rank = 1;
      snapshot.forEach((doc) => {
        const data = doc.data();
        const safeName = escapeHtml(data.name);
        html += `
          <div style="display:flex; justify-content:space-between; border-bottom:1px dotted #444; padding:5px 0; color:#aaa;">
            <span style="color:var(--retro-highlight); width:30px;">#${rank}</span>
            <span style="flex-grow:1; text-align:left;">${safeName}</span>
            <span style="color:var(--retro-pink);">${data.score}</span>
          </div>`;
        rank++;
      });
      hsDiv.innerHTML = html;
    }, (error) => {
      hsDiv.innerHTML = "<div style='color:#f00'>DB ERROR</div>";
    });
}

function escapeHtml(text) {
  if (!text) return text;
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

// ==========================================
// 2. AUDIO ENGINE
// ==========================================
class AudioSys {
  constructor() {
    this.ctx = null;
    this.master = null;
    this.noiseBuffer = null;
    this.nextNoteTime = 0;
    this.noteIndex = 0;
    this.mode = 'retro'; 
    this.tempoRetro = 0.13;
    this.tempoSpace = 2.0; 
    this.tempoMenu = 3.0;
    this.scaleRetro = [110.00, 130.81, 146.83, 164.81, 196.00, 220.00]; 
    this.spaceNotes = [55, 65.41, 73.42, 82.41, 98, 110, 130.81]; 
    this.menuNotes = [220.00, 329.63, 392.00, 493.88, 587.33]; 
    this.droneOsc = null;
    this.droneGain = null;
    this.isPlaying = false;
  }

  setMode(m) { this.mode = m; }

  init() {
    if (this.ctx) return; 
    try {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return; 
        
        this.ctx = new Ctx();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.4; 
        this.master.connect(this.ctx.destination);
        
        const bufSize = this.ctx.sampleRate * 2; 
        this.noiseBuffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const delay = this.ctx.createDelay();
        delay.delayTime.value = 0.4;
        const delayFb = this.ctx.createGain();
        delayFb.gain.value = 0.4;
        const delayFilter = this.ctx.createBiquadFilter();
        delayFilter.frequency.value = 1500; 
        
        this.master.connect(delay);
        delay.connect(delayFilter);
        delayFilter.connect(delayFb);
        delayFb.connect(delay);
        delay.connect(this.ctx.destination);
        
        this.delayNode = delay;
        this.delayFbNode = delayFb;
    } catch(e) {}
  }
  
  updateDelaySettings(active) {
      if(!this.delayNode) return;
      try {
        if (!active) {
            this.delayNode.delayTime.rampToValueAtTime(0.45, this.ctx.currentTime + 1);
            this.delayFbNode.gain.rampToValueAtTime(0.6, this.ctx.currentTime + 1);
        } else if (this.mode === 'space') {
            this.delayNode.delayTime.rampToValueAtTime(0.6, this.ctx.currentTime + 1);
            this.delayFbNode.gain.rampToValueAtTime(0.6, this.ctx.currentTime + 1);
        } else {
            this.delayNode.delayTime.rampToValueAtTime(0.25, this.ctx.currentTime + 1);
            this.delayFbNode.gain.rampToValueAtTime(0.3, this.ctx.currentTime + 1);
        }
      } catch(e) {}
  }
  
  updateDrone(active) {
      if (!this.ctx) return;
      const t = this.ctx.currentTime;
      if (!active && !this.droneOsc) {
          this.droneOsc = this.ctx.createOscillator();
          this.droneOsc.type = 'sawtooth';
          this.droneOsc.frequency.value = 55.00; 
          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 90; 
          this.droneGain = this.ctx.createGain();
          this.droneGain.gain.setValueAtTime(0, t);
          this.droneGain.gain.linearRampToValueAtTime(0.2, t + 3.0); 
          this.droneOsc.connect(filter);
          filter.connect(this.droneGain);
          this.droneGain.connect(this.master);
          this.droneOsc.start(t);
      } else if (active && this.droneOsc) {
          this.droneGain.gain.cancelScheduledValues(t);
          this.droneGain.gain.setValueAtTime(this.droneGain.gain.value, t);
          this.droneGain.gain.exponentialRampToValueAtTime(0.001, t + 1.0); 
          this.droneOsc.stop(t + 1.1);
          this.droneOsc = null;
          this.droneGain = null;
      }
  }

  resume() { try { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); } catch(e) {} }

  playBGM() {
    if (!this.ctx || !this.isPlaying) return;
    try {
        this.updateDrone(State.active);
        let currentTempo = (!State.active) ? this.tempoMenu : (this.mode === 'space' ? this.tempoSpace : this.tempoRetro);
        
        while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
          if (!State.active) this.triggerMenuNote(this.nextNoteTime);
          else if (this.mode === 'space') this.triggerSpaceNote(this.nextNoteTime);
          else this.triggerRetroNote(this.nextNoteTime);
          this.nextNoteTime += currentTempo;
        }
        if (this.ctx.currentTime % 2 < 0.1) this.updateDelaySettings(State.active);
    } catch(e) {}
  }

  triggerMenuNote(t) {
    const note = this.menuNotes[this.noteIndex % this.menuNotes.length];
    const octave = Math.random() > 0.6 ? 2 : 1; 
    const osc = this.ctx.createOscillator();
    osc.type = 'sine'; osc.frequency.value = note * octave;
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.08, t + 0.1); 
    gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0); 
    osc.connect(gain); gain.connect(this.master);
    osc.start(t); osc.stop(t + 2.5); this.noteIndex++;
  }

  triggerRetroNote(t) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const pattern = [0, 2, 3, 5, 7, 5, 3, 2, 0, 0, -3, 0, 2, 0, -3, -5];
    const idx = this.noteIndex % pattern.length;
    let noteIdx = pattern[idx];
    let freq = (noteIdx >= 0) ? this.scaleRetro[noteIdx % this.scaleRetro.length] * (1 + Math.floor(noteIdx/this.scaleRetro.length)) : this.scaleRetro[0]/2;
    osc.frequency.value = freq;
    
    if (idx % 4 === 0) {
      osc.type = 'sawtooth'; gain.gain.setValueAtTime(0.15, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
    } else {
      osc.type = 'square'; gain.gain.setValueAtTime(0.05, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    }
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass'; filter.frequency.setValueAtTime(800, t); filter.frequency.linearRampToValueAtTime(100, t + 0.2);
    osc.connect(filter); filter.connect(gain); gain.connect(this.master);
    osc.start(t); osc.stop(t + 0.4); this.noteIndex++;
  }

  triggerSpaceNote(t) {
    const freq = this.spaceNotes[Math.floor(Math.random() * this.spaceNotes.length)];
    const octave = Math.random() > 0.7 ? 2 : 1;
    const carrier = this.ctx.createOscillator(); carrier.type = 'sine'; carrier.frequency.value = freq * octave;
    const modulator = this.ctx.createOscillator(); modulator.type = 'triangle'; modulator.frequency.value = freq * 2.02; 
    const modGain = this.ctx.createGain(); modGain.gain.value = 100; 
    modulator.connect(modGain); modGain.connect(carrier.frequency);
    const masterGain = this.ctx.createGain();
    masterGain.gain.setValueAtTime(0, t); masterGain.gain.linearRampToValueAtTime(0.2, t + 0.5); masterGain.gain.exponentialRampToValueAtTime(0.001, t + 2.5); 
    carrier.connect(masterGain); masterGain.connect(this.master);
    carrier.start(t); carrier.stop(t + 3.0); modulator.start(t); modulator.stop(t + 3.0);
    this.noteIndex++;
  }

  sfxThrust() {
    if (!this.ctx) return;
    try {
        const t = this.ctx.currentTime;
        const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuffer;
        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 600; 
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.08, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15); 
        src.connect(filter); filter.connect(gain); gain.connect(this.master);
        src.start(t); src.stop(t + 0.2);
    } catch(e){}
  }

  sfxCrash() {
    if (!this.ctx) return;
    try {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.5);
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        osc.connect(gain); gain.connect(this.master);
        osc.start(t); osc.stop(t+0.6);
    } catch(e){}
  }

  startMusic() { 
      try {
        if (!this.ctx) this.init(); 
        this.isPlaying = true; 
        if(this.ctx) {
            if (this.nextNoteTime < this.ctx.currentTime) this.nextNoteTime = this.ctx.currentTime + 0.1; 
            this.updateDelaySettings(State.active);
        }
      } catch(e) {}
  }
}

// ==========================================
// 3. GAME ENGINE
// ==========================================
const Audio = new AudioSys();
const btnRetro = document.getElementById('btnAudioRetro');
const btnSpace = document.getElementById('btnAudioSpace');

if (btnRetro && btnSpace) {
    btnRetro.addEventListener('click', () => { Audio.setMode('retro'); btnRetro.classList.add('active'); btnSpace.classList.remove('active'); });
    btnSpace.addEventListener('click', () => { Audio.setMode('space'); btnSpace.classList.add('active'); btnRetro.classList.remove('active'); });
}

// Physics Constants
const CFG = {
  W: 1200, H: 800, GRAVITY: 0, THRUST: 600, DRAG: 2.0, SCROLL_V0: 150, SCROLL_ACCEL: 8,
  SEG_LEN: 300, WALL_GAP: 500, K_COULOMB: 80, K_LIKE_BASE: 15.0, DIELECTRIC_MULT: 1.0, 
  DIST_SCALE: 100, ISO_ANGLE: 0.6, FOV: 600
};

const State = {
  active: false, paused: false, over: false, time: 0, score: 0, distance: 0, speed: CFG.SCROLL_V0,
  player: { y: 0, vy: 0, q: 1 }, trail: [], segments: [], particles: [], forces: { topC:0, topP:0, botC:0, botP:0 }
};

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let bounds = { w: 0, h: 0 };
let PLAYER_OFFSET = 200; // Will be dynamic based on screen width

// Mobile: Resize handles pixel density and aspect ratio
function resize() {
  const dpr = window.devicePixelRatio || 1;
  bounds.w = window.innerWidth; 
  bounds.h = window.innerHeight;
  
  canvas.width = bounds.w * dpr; 
  canvas.height = bounds.h * dpr;
  
  ctx.scale(dpr, dpr);
  
  // Dynamic Player Position: 15% of screen width to allow reaction time on narrow vertical screens
  PLAYER_OFFSET = Math.min(200, bounds.w * 0.15); 
}
window.addEventListener('resize', resize);
resize();

const Input = { up: false, down: false };

// --- TOUCH CONTROLS (BUTTONS) ---
const btnUpPad = document.getElementById('btnUpPad');
const btnDownPad = document.getElementById('btnDownPad');

const handleTouchStart = (dir, btn) => (e) => {
    e.preventDefault(); // Stop zoom/scroll
    Input[dir] = true;
    btn.classList.add('pressed');
};
const handleTouchEnd = (dir, btn) => (e) => {
    e.preventDefault();
    Input[dir] = false;
    btn.classList.remove('pressed');
};

if (btnUpPad) {
    btnUpPad.addEventListener('touchstart', handleTouchStart('up', btnUpPad), {passive:false});
    btnUpPad.addEventListener('touchend', handleTouchEnd('up', btnUpPad), {passive:false});
    // Add Mouse events for desktop testing of mobile view
    btnUpPad.addEventListener('mousedown', () => Input.up = true);
    btnUpPad.addEventListener('mouseup', () => Input.up = false);
}
if (btnDownPad) {
    btnDownPad.addEventListener('touchstart', handleTouchStart('down', btnDownPad), {passive:false});
    btnDownPad.addEventListener('touchend', handleTouchEnd('down', btnDownPad), {passive:false});
    btnDownPad.addEventListener('mousedown', () => Input.down = true);
    btnDownPad.addEventListener('mouseup', () => Input.down = false);
}

// --- SWIPE BACKUP ---
let touchStartY = 0;
window.addEventListener('touchstart', e => {
  if (e.target.tagName === 'CANVAS' || e.target.id === 'overlayStart') {
     touchStartY = e.touches[0].clientY;
  }
}, { passive: true });

window.addEventListener('touchmove', e => {
    if (e.target.tagName === 'CANVAS') e.preventDefault(); // prevent scroll
}, { passive: false });

// Keyboard Backup
window.addEventListener('keydown', e => {
  if(e.code === 'ArrowUp' || e.code === 'KeyW') Input.up = true;
  if(e.code === 'ArrowDown' || e.code === 'KeyS') Input.down = true;
});
window.addEventListener('keyup', e => {
  if(e.code === 'ArrowUp' || e.code === 'KeyW') Input.up = false;
  if(e.code === 'ArrowDown' || e.code === 'KeyS') Input.down = false;
});

const uiScore = document.getElementById('uiScore');
const uiSpeed = document.getElementById('uiSpeed');
const uiField = document.getElementById('uiField');
const overlayStart = document.getElementById('overlayStart');
const overlayGO = document.getElementById('overlayGO');
const overlayInfo = document.getElementById('overlayInfo');
const btnStart = document.getElementById('btnStart');
const btnRetry = document.getElementById('btnRetry');
const btnNewPilot = document.getElementById('btnNewPilot');
const btnInfo = document.getElementById('btnInfo');
const btnCloseInfo = document.getElementById('btnCloseInfo');
const pNameInput = document.getElementById('pName');

// NAME FILTER
pNameInput.addEventListener('input', function(e) {
  let val = e.target.value;
  val = val.toLowerCase().replace(/\s/g, ''); 
  e.target.value = val;
});

btnInfo.addEventListener('click', () => {
    overlayInfo.classList.remove('hidden');
    if (State.active) { State.active = false; State.paused = true; }
});
btnCloseInfo.addEventListener('click', () => {
    overlayInfo.classList.add('hidden');
    if (State.paused) { State.active = true; State.paused = false; }
});

const defaultText = "INSERT NAME";
const savedName = localStorage.getItem("ion_runner_name");

if (savedName && savedName !== "guest") {
    pNameInput.value = savedName;
} else {
    pNameInput.value = defaultText;
    pNameInput.classList.add('input-attention');
}

pNameInput.addEventListener('focus', () => {
    if (pNameInput.value === defaultText) {
        pNameInput.value = "";
        pNameInput.classList.remove('input-attention');
    }
});
pNameInput.addEventListener('blur', () => {
    if (pNameInput.value.trim() === "") {
        pNameInput.value = defaultText;
        pNameInput.classList.add('input-attention');
    }
});

btnStart.addEventListener('click', startGame);
btnRetry.addEventListener('click', resetGame);
btnNewPilot.addEventListener('click', goToMenu);

function startGame() {
  const val = pNameInput.value;
  if (!val || val.trim() === "" || val === defaultText) {
    pNameInput.classList.add('input-error');
    setTimeout(() => pNameInput.classList.remove('input-error'), 400);
    return;
  }

  if (pNameInput) localStorage.setItem("ion_runner_name", pNameInput.value);
  
  // Mobile Audio Unlock
  if(!Audio.ctx) Audio.init(); 
  Audio.resume(); 
  Audio.startMusic();
  
  overlayStart.classList.add('hidden');
  resetPhysics();
  State.active = true; State.over = false; State.paused = false;
}

function resetGame() {
  overlayGO.classList.add('hidden');
  resetPhysics();
  State.active = true; State.over = false;
  try { Audio.startMusic(); } catch(e){}
}

function goToMenu() {
    overlayGO.classList.add('hidden'); 
    overlayStart.classList.remove('hidden');
    State.active = false; State.paused = false; State.over = false;
}

function resetPhysics() {
  State.time = 0; State.score = 0; State.distance = 0; State.speed = CFG.SCROLL_V0;
  State.player.y = 0; State.player.vy = 0;
  State.segments = []; State.particles = []; State.trail = [];
  State.forces = { topC:0, topP:0, botC:0, botP:0 };
  for(let i=0; i<10; i++) addSegment(i * CFG.SEG_LEN);
}

function addSegment(x) {
  const isSafe = x < 600; 
  const progression = Math.floor(State.distance / 3000);
  const qMax = Math.min(30, 10 + progression * 2);
  const getMag = () => Math.floor(Math.random() * (qMax - 1)) + 1; 
  let qTop = isSafe ? 0 : (Math.random() > 0.5 ? 1 : -1) * getMag();
  let qBot = isSafe ? 0 : (Math.random() > 0.5 ? 1 : -1) * getMag();
  if(Math.random() < 0.25 && !isSafe) qTop = Math.abs(qTop) * 1.5; 
  State.segments.push({ x: x, w: CFG.SEG_LEN, qTop, qBot });
}

function update(dt) {
  State.time += dt; State.speed += CFG.SCROLL_ACCEL * dt; State.distance += State.speed * dt;
  State.score = Math.floor(State.distance / 10);
  
  const lastSeg = State.segments[State.segments.length-1];
  if (lastSeg.x < State.distance + bounds.w + 500) addSegment(lastSeg.x + CFG.SEG_LEN);
  if (State.segments[0].x + CFG.SEG_LEN < State.distance - 1000) State.segments.shift();
  
  const p = State.player;
  // Collision Check uses PLAYER_OFFSET instead of hardcoded 200
  const currSeg = State.segments.find(s => s.x <= State.distance + PLAYER_OFFSET && s.x + CFG.SEG_LEN > State.distance + PLAYER_OFFSET) || State.segments[0];
  
  let thrust = 0;
  if (Input.up) thrust -= CFG.THRUST;
  if (Input.down) thrust += CFG.THRUST;
  
  const distScale = CFG.DIST_SCALE;
  const dTop = (p.y - (-CFG.WALL_GAP/2));
  const dBot = ((CFG.WALL_GAP/2) - p.y);
  const dtS = Math.max(5, dTop) / distScale;
  const dbS = Math.max(5, dBot) / distScale;
  
  const K_LIKE = CFG.K_LIKE_BASE * CFG.DIELECTRIC_MULT;
  
  const F_Top_C = (CFG.K_COULOMB * currSeg.qTop) / (dtS*dtS);
  const F_Top_P = (K_LIKE * currSeg.qTop*currSeg.qTop) / (dtS*dtS*dtS);
  const F_Top = F_Top_C - F_Top_P; 

  const F_Bot_C = (CFG.K_COULOMB * currSeg.qBot) / (dbS*dbS); 
  const F_Bot_P = (K_LIKE * currSeg.qBot*currSeg.qBot) / (dbS*dbS*dbS);
  const F_Bot_Net = -( (CFG.K_COULOMB * currSeg.qBot) / (dbS*dbS) ) + F_Bot_P;
  
  const totalAy = CFG.GRAVITY + thrust + F_Top + F_Bot_Net;
  
  State.forces.topC = Math.abs(F_Top_C); State.forces.topP = Math.abs(F_Top_P);
  State.forces.botC = Math.abs(F_Bot_C); State.forces.botP = Math.abs(F_Bot_P);
  
  p.vy += totalAy * dt;
  p.vy *= Math.exp(-CFG.DRAG * dt);
  p.y += p.vy * dt;

  // Track Trail using PLAYER_OFFSET
  State.trail.push({ x: State.distance + PLAYER_OFFSET, y: p.y });
  if (State.trail.length > 80) State.trail.shift(); // Shorter trail for mobile performance

  if (Input.up || Input.down) {
    if (Math.random() < 0.6) {
      const exhaustDir = Input.up ? 1 : -1; 
      State.particles.push({
        x: State.distance + PLAYER_OFFSET, y: p.y, vx: -State.speed - Math.random()*50, 
        vy: exhaustDir * (100 + Math.random()*100), life: 0.8, color: Input.up ? '#0ff' : '#f0f' 
      });
      Audio.sfxThrust();
    }
  }
  
  for (let i=State.particles.length-1; i>=0; i--) {
    let pt = State.particles[i]; pt.x += pt.vx * dt; pt.y += pt.vy * dt; pt.life -= dt * 2.5; 
    if (pt.life <= 0) State.particles.splice(i, 1);
  }
  
  if (p.y < -CFG.WALL_GAP/2 + 20 || p.y > CFG.WALL_GAP/2 - 20) gameOver();

  uiScore.innerText = State.score; uiSpeed.innerText = Math.floor(State.speed);
  const netF = (F_Top + F_Bot_Net);
  uiField.innerText = netF.toFixed(0); uiField.style.color = Math.abs(netF) > 1000 ? '#ff0055' : '#00f3ff';
}

function gameOver() {
  State.active = false; State.over = true;
  Audio.sfxCrash();
  
  const finalScore = State.score;
  const pilotName = pNameInput.value.trim() || "pilot";
  
  document.getElementById('goScoreDisplay').innerHTML = `SCORE: <span style="color: var(--accent); text-shadow: 0 0 10px var(--accent);">${finalScore}</span>`;

  overlayGO.classList.remove('hidden');
  loadGlobalScores();

  if (db && finalScore > 0) {
    db.collection("scores").add({
      name: pilotName,
      score: finalScore,
      date: firebase.firestore.FieldValue.serverTimestamp()
    })
    .catch((error) => { console.error("Database Write Error:", error); });
  }
}

// ==========================================
// 4. RENDERER
// ==========================================
function render() {
  ctx.fillStyle = "#050510";
  ctx.fillRect(0, 0, bounds.w, bounds.h);
  
  const cx = bounds.w / 2;
  const cy = bounds.h / 2;
  
  // Grid
  ctx.save();
  ctx.strokeStyle = "rgba(0, 243, 255, 0.1)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  const gridOff = -(State.distance % 100);
  for(let i=0; i<bounds.w/100 + 2; i++){
    let gx = i*100 + gridOff;
    ctx.moveTo(gx, 0); ctx.lineTo(gx, bounds.h);
  }
  for(let i=0; i<bounds.h/100; i++){
    ctx.moveTo(0, i*100); ctx.lineTo(bounds.w, i*100);
  }
  ctx.stroke();
  ctx.restore();

  // Identify current segment
  const currentSegment = State.segments.find(s => s.x <= State.distance + PLAYER_OFFSET && s.x + CFG.SEG_LEN > State.distance + PLAYER_OFFSET) || State.segments[0];

  // Walls
  const wallDepth = 60; 
  const viewTilt = 0.4; 
  
  if (State.segments.length > 0) {
      State.segments.forEach(s => {
        // Use PLAYER_OFFSET for x-positioning to align with dynamic player
        const x1 = (s.x - State.distance) + PLAYER_OFFSET; 
        const x2 = (s.x + CFG.SEG_LEN - State.distance) + PLAYER_OFFSET;
        
        if (x2 < -100 || x1 > bounds.w + 100) return; // Optimization for mobile culling
        
        const yTop = cy - CFG.WALL_GAP/2;
        const yBot = cy + CFG.WALL_GAP/2;
        const hWall = 200;
        
        const isActiveSegment = (s === currentSegment);

        const getC = (q) => {
          if (q === 0) return [60, 60, 70];
          if (q > 0) return [0, 243, 255]; 
          return [255, 0, 85];             
        };
        
        const drawBlock = (yBase, h, q, isCeiling) => {
          let c = getC(q);
          let intensity = Math.min(1, Math.abs(q)/10); 
          let alpha = (q === 0) ? 0.8 : (0.3 + 0.7*intensity);
          
          let isLCA = false;
          if (isActiveSegment && q > 0) {
              if (isCeiling) { if (State.forces.topP > State.forces.topC) isLCA = true; } 
              else { if (State.forces.botP > State.forces.botC) isLCA = true; }
          }

          let colStr;
          if (isLCA) { colStr = "rgba(255, 255, 255, 1.0)"; alpha = 1.0; } 
          else { colStr = `rgba(${c[0]},${c[1]},${c[2]},${alpha})`; }

          const offX = wallDepth; 
          const offY = isCeiling ? wallDepth * viewTilt : -wallDepth * viewTilt;
          const yEdge = yBase;
          const yFar = isCeiling ? yBase - h : yBase + h;
          
          // Draw 3D side
          ctx.beginPath();
          ctx.moveTo(x1, yEdge);
          ctx.lineTo(x2, yEdge);
          ctx.lineTo(x2 + offX, yEdge + offY);
          ctx.lineTo(x1 + offX, yEdge + offY);
          ctx.closePath();
          if (isLCA) ctx.fillStyle = "#ccc"; 
          else ctx.fillStyle = `rgba(${c[0]*0.5},${c[1]*0.5},${c[2]*0.5},${alpha})`; 
          ctx.fill();
          ctx.strokeStyle = colStr; ctx.lineWidth = 1; ctx.stroke();

          // Draw Front Face
          ctx.beginPath();
          ctx.moveTo(x1, yEdge);
          ctx.lineTo(x2, yEdge);
          ctx.lineTo(x2, yFar);
          ctx.lineTo(x1, yFar);
          ctx.closePath();
          
          if (Math.abs(q) > 0) {
            ctx.shadowBlur = isLCA ? 40 : (20 + Math.abs(q)*2);
            ctx.shadowColor = colStr;
          }
          
          if (isLCA) ctx.fillStyle = "#fff";
          else ctx.fillStyle = `rgba(${c[0]*0.2},${c[1]*0.2},${c[2]*0.2}, 0.9)`; 
          
          ctx.fill(); ctx.stroke(); ctx.shadowBlur = 0;
          
          /*
          if (Math.abs(q) > 0) {
            ctx.fillStyle = isLCA ? "#000" : "#fff";
            ctx.font = "bold 20px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(q > 0 ? "+" + q.toFixed(0) : q.toFixed(0), (x1+x2)/2, (yEdge + yFar)/2);
          }
          */
        };
        drawBlock(yTop, hWall, s.qTop, true);
        drawBlock(yBot, hWall, s.qBot, false);
      });
  }

  // Trail
  if (State.trail.length > 1) {
    ctx.save();
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.shadowBlur = 10;
    ctx.shadowColor = "#00f3ff";
    ctx.strokeStyle = "rgba(0, 243, 255, 0.2)"; 
    ctx.lineWidth = 6;
    for (let i = 0; i < State.trail.length; i++) {
      const p = State.trail[i];
      const sx = (p.x - State.distance);
      const sy = cy + p.y;
      if(i===0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    ctx.stroke();
    ctx.restore();
  }

  // Particles
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for(let p of State.particles) {
    const ppx = (p.x - State.distance); 
    const ppy = cy + p.y;
    if (ppx < -50 || ppx > bounds.w + 50) continue;

    ctx.beginPath();
    ctx.arc(ppx, ppy, 3*p.life, 0, Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life;
    ctx.fill();
  }
  ctx.restore();
  
  // PLAYER RENDER
  const px = PLAYER_OFFSET; 
  const py = cy + State.player.y;
  
  ctx.save();
  
  ctx.shadowBlur = 20;
  ctx.shadowColor = "#fff";
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(px, py, 10, 0, Math.PI*2);
  ctx.fill();
  
  ctx.shadowBlur = 40;
  ctx.shadowColor = "#00f3ff";
  ctx.strokeStyle = "#00f3ff";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(px, py, 16 + Math.sin(Date.now()/100)*2, 0, Math.PI*2);
  ctx.stroke();
  
  ctx.shadowBlur = 0;
  ctx.fillStyle = "#000";
  ctx.font = "bold 12px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("+1", px, py);
  
  ctx.restore();
}

function loop() {
  const now = performance.now();
  const dt = Math.min(0.05, (now - (State.lastTime || now)) / 1000);
  State.lastTime = now;
  
  if (State.active) update(dt);
  
  Audio.playBGM();
  render();
  requestAnimationFrame(loop);
}

// Initial physics setup
resetPhysics();
loop();
</script>
</body>
</html>
